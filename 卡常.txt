https://www.luogu.com.cn/article/igm2xr3e

松基模板

void sort(u32 *f,u32 *l) {
    #define base 255
    register u32 Cnt1[257],Cnt2[257],Cnt3[257],Cnt4[257];
    u32 i,*ii;
    u32 *cnt1=Cnt1+1,*cnt2=Cnt2+1,*cnt3=Cnt3+1,*cnt4=Cnt4+1,
	*use=(u32*)malloc(sizeof(u32)*(l-f)),*ul=use+(l-f);
    for(i=0;i<257;i++){Cnt1[i]=0;Cnt2[i]=0;Cnt3[i]=0;Cnt4[i]=0;}
    for(ii=f;ii!=l;ii++){cnt1[(*ii)&base]++;cnt2[((*ii)>>8)&base]++;
	cnt3[((*ii)>>16)&base]++;cnt4[(*ii)>>24]++;}
	cnt1--;cnt2--;cnt3--;cnt4--;
	for(i=1;i<257;i++){cnt1[i]+=cnt1[i-1];cnt2[i]+=cnt2[i-1];
	cnt3[i]+=cnt3[i-1];cnt4[i]+=cnt4[i-1];}
	for(ii=f;ii!=l;ii++)use[cnt1[(*ii)&base]++]=*ii;
	for(ii=use;ii!=ul;ii++)f[cnt2[((*ii)>>8)&base]++]=*ii;
	for(ii=f;ii!=l;ii++)use[cnt3[((*ii)>>16)&base]++]=*ii;
	for(ii=use;ii!=ul;ii++)f[cnt4[(*ii)>>24]++]=*ii;
}


快速阶乘

#include<stdio.h>
#include<immintrin.h>
#pragma GCC target("avx2")
static unsigned mod,r,n2_;
static __m256i a0,mod1,R,hi32,ad;
long long exgcd(long long a,long long b,long long &x,long long &y)
{
	long long d=a;
	if(b==0) x=1,y=0;
	else d=exgcd(b,a%b,y,x),y-=a/b*x;
	return d;
}
inline unsigned mul(unsigned x,unsigned y)//蒙哥马利模乘
{
	unsigned long long z=(unsigned long long)x*y;
	return (z+(unsigned long long)(unsigned(z)*r)*mod)>>32;
}
inline __m256i add(__m256i _num1,__m256i _num2)
{
	__m256i apb=_mm256_add_epi32(_num1,_num2),ret=_mm256_sub_epi32(apb,mod1);
	__m256i cmp=_mm256_cmpgt_epi32(a0,ret),add=_mm256_and_si256(cmp,mod1);
	return _mm256_add_epi32(add,ret);
}
inline __m256i mul(__m256i _num1,__m256i _num2)
{
	__m256i _num3=_num1,_num4,_num5=_num2;
	_num2=_mm256_mul_epu32(_num1,_num2);
	_num1=_mm256_mul_epu32(_mm256_mul_epu32(_num2,R),mod1);
    _num4=_mm256_srli_epi64(_mm256_add_epi64(_num1,_num2),32);
	_num1=_mm256_srli_si256(_num3,4);_num2=_mm256_srli_si256(_num5,4);
	_num2=_mm256_mul_epu32(_num1,_num2);
	_num1=_mm256_mul_epu32(_mm256_mul_epu32(_num2,R),mod1);
    _num1=_mm256_and_si256(_mm256_add_epi64(_num1,_num2),hi32);
    return _mm256_or_si256(_num1,_num4);
}
inline unsigned mon_in(unsigned x){return mul(x,n2_);}//进入数域
inline unsigned mon_out(unsigned x)//离开数域
{unsigned ret=((x+(unsigned long long)(unsigned(x)*r)*mod)>>32);return ret<mod?ret:ret-mod;}
inline unsigned qpow(unsigned n,unsigned m,unsigned p)
{
	if(!m) return 1;
	unsigned ret=qpow(n,m>>1,p);ret=1ull*ret*ret%p;
	if(m&1) return 1ull*ret*n%p;
	else return ret; 
}
void solve(int N,const unsigned p)
{
	#define mv 8
	int n=N-(N&(256*(1<<mv)-1));
	long long x,y;
	mod=p;
	n2_=-(unsigned long long)mod%mod;exgcd(mod,1ll<<32,x,y);r=-unsigned(x);//初始化蒙哥马利约减参数
	a0=_mm256_setzero_si256(),
	mod1=_mm256_set1_epi32(mod),R=_mm256_set1_epi32(r);
	hi32=_mm256_set_epi32(-1,0,-1,0,-1,0,-1,0);
	unsigned as=mon_in(1),as2=mon_in(1);
	unsigned *fl;
	{
	__m256i ans[8]={_mm256_set1_epi32(mon_in(1)),_mm256_set1_epi32(mon_in(1))
	,_mm256_set1_epi32(mon_in(1)),_mm256_set1_epi32(mon_in(1)),
	_mm256_set1_epi32(mon_in(1)),_mm256_set1_epi32(mon_in(1))
	,_mm256_set1_epi32(mon_in(1)),_mm256_set1_epi32(mon_in(1))};
	ad=_mm256_set1_epi32(mon_in(64));
	__m256i ml[8]={_mm256_set_epi32(mon_in(8),mon_in(7),mon_in(6),mon_in(5),mon_in(4),mon_in(3),mon_in(2),mon_in(1)),
	_mm256_set_epi32(mon_in(16),mon_in(15),mon_in(14),mon_in(13),mon_in(12),mon_in(11),mon_in(10),mon_in(9)),
	_mm256_set_epi32(mon_in(24),mon_in(23),mon_in(22),mon_in(21),mon_in(20),mon_in(19),mon_in(18),mon_in(17)),
	_mm256_set_epi32(mon_in(32),mon_in(31),mon_in(30),mon_in(29),mon_in(28),mon_in(27),mon_in(26),mon_in(25)),
	_mm256_set_epi32(mon_in(40),mon_in(39),mon_in(38),mon_in(37),mon_in(36),mon_in(35),mon_in(34),mon_in(33)),
	_mm256_set_epi32(mon_in(48),mon_in(47),mon_in(46),mon_in(45),mon_in(44),mon_in(43),mon_in(42),mon_in(41)),
	_mm256_set_epi32(mon_in(56),mon_in(55),mon_in(54),mon_in(53),mon_in(52),mon_in(51),mon_in(50),mon_in(49)),
	_mm256_set_epi32(mon_in(64),mon_in(63),mon_in(62),mon_in(61),mon_in(60),mon_in(59),mon_in(58),mon_in(57))};
	for(unsigned i=1;i+63<=n>>mv;i+=64)
	{
		ans[0]=mul(ans[0],ml[0]);
		ans[1]=mul(ans[1],ml[1]);
		ans[2]=mul(ans[2],ml[2]);
		ans[3]=mul(ans[3],ml[3]);
		ans[4]=mul(ans[4],ml[4]);
		ans[5]=mul(ans[5],ml[5]);
		ans[6]=mul(ans[6],ml[6]);
		ans[7]=mul(ans[7],ml[7]);
		ml[0]=add(ml[0],ad);
		ml[1]=add(ml[1],ad);
		ml[2]=add(ml[2],ad);
		ml[3]=add(ml[3],ad);
		ml[4]=add(ml[4],ad);
		ml[5]=add(ml[5],ad);
		ml[6]=add(ml[6],ad);
		ml[7]=add(ml[7],ad);
	}
	fl=(unsigned*)(ans+0);
	as=mul(as,mul(mul(fl[1],fl[3]),mul(fl[5],fl[7])));
	as2=mul(as2,mul(mul(fl[0],fl[2]),mul(fl[4],fl[6])));
	fl=(unsigned*)(ans+1);
	as=mul(as,mul(mul(fl[1],fl[3]),mul(fl[5],fl[7])));
	as2=mul(as2,mul(mul(fl[0],fl[2]),mul(fl[4],fl[6])));
	fl=(unsigned*)(ans+2);
	as=mul(as,mul(mul(fl[1],fl[3]),mul(fl[5],fl[7])));
	as2=mul(as2,mul(mul(fl[0],fl[2]),mul(fl[4],fl[6])));
	fl=(unsigned*)(ans+3);
	as=mul(as,mul(mul(fl[1],fl[3]),mul(fl[5],fl[7])));
	as2=mul(as2,mul(mul(fl[0],fl[2]),mul(fl[4],fl[6])));
	fl=(unsigned*)(ans+4);
	as=mul(as,mul(mul(fl[1],fl[3]),mul(fl[5],fl[7])));
	as2=mul(as2,mul(mul(fl[0],fl[2]),mul(fl[4],fl[6])));
	fl=(unsigned*)(ans+5);
	as=mul(as,mul(mul(fl[1],fl[3]),mul(fl[5],fl[7])));
	as2=mul(as2,mul(mul(fl[0],fl[2]),mul(fl[4],fl[6])));
	fl=(unsigned*)(ans+6);
	as=mul(as,mul(mul(fl[1],fl[3]),mul(fl[5],fl[7])));
	as2=mul(as2,mul(mul(fl[0],fl[2]),mul(fl[4],fl[6])));
	fl=(unsigned*)(ans+7);
	as=mul(as,mul(mul(fl[1],fl[3]),mul(fl[5],fl[7])));
	as2=mul(as2,mul(mul(fl[0],fl[2]),mul(fl[4],fl[6])));
	}
	for(int j=mv-1;j>=0;j--)
	{
	as=mul(as,as2);
	as=mul(as,mon_in(qpow(2,n>>(j+1),p)));//as偶数项,as2前半奇数项 
	__m256i ans[8]={_mm256_set1_epi32(mon_in(1)),_mm256_set1_epi32(mon_in(1))
	,_mm256_set1_epi32(mon_in(1)),_mm256_set1_epi32(mon_in(1)),
	_mm256_set1_epi32(mon_in(1)),_mm256_set1_epi32(mon_in(1))
	,_mm256_set1_epi32(mon_in(1)),_mm256_set1_epi32(mon_in(1))};
	ad=_mm256_set1_epi32(mon_in(128));
	const unsigned add_=n>>(j+1);
	__m256i ml[8]={_mm256_set_epi32(mon_in(add_+15),mon_in(add_+13),mon_in(add_+11),mon_in(add_+9)
	,mon_in(add_+7),mon_in(add_+5),mon_in(add_+3),mon_in(add_+1)),
	_mm256_set_epi32(mon_in(add_+31),mon_in(add_+29),mon_in(add_+27),mon_in(add_+25)
	,mon_in(add_+23),mon_in(add_+21),mon_in(add_+19),mon_in(add_+17)),
	_mm256_set_epi32(mon_in(add_+47),mon_in(add_+45),mon_in(add_+43),mon_in(add_+41)
	,mon_in(add_+39),mon_in(add_+37),mon_in(add_+35),mon_in(add_+33)),
	_mm256_set_epi32(mon_in(add_+63),mon_in(add_+61),mon_in(add_+59),mon_in(add_+57)
	,mon_in(add_+55),mon_in(add_+53),mon_in(add_+51),mon_in(add_+49)),
	_mm256_set_epi32(mon_in(add_+79),mon_in(add_+77),mon_in(add_+75),mon_in(add_+73)
	,mon_in(add_+71),mon_in(add_+69),mon_in(add_+67),mon_in(add_+65)),
	_mm256_set_epi32(mon_in(add_+95),mon_in(add_+93),mon_in(add_+91),mon_in(add_+89)
	,mon_in(add_+87),mon_in(add_+85),mon_in(add_+83),mon_in(add_+81)),
	_mm256_set_epi32(mon_in(add_+111),mon_in(add_+109),mon_in(add_+107),mon_in(add_+105)
	,mon_in(add_+103),mon_in(add_+101),mon_in(add_+99),mon_in(add_+97)),
	_mm256_set_epi32(mon_in(add_+127),mon_in(add_+125),mon_in(add_+123),mon_in(add_+121)
	,mon_in(add_+119),mon_in(add_+117),mon_in(add_+115),mon_in(add_+113))};
	for(unsigned i=add_;i+127<=n>>j;i+=128)
	{
		ans[0]=mul(ans[0],ml[0]);
		ans[1]=mul(ans[1],ml[1]);
		ans[2]=mul(ans[2],ml[2]);
		ans[3]=mul(ans[3],ml[3]);
		ans[4]=mul(ans[4],ml[4]);
		ans[5]=mul(ans[5],ml[5]);
		ans[6]=mul(ans[6],ml[6]);
		ans[7]=mul(ans[7],ml[7]);
		ml[0]=add(ml[0],ad);
		ml[1]=add(ml[1],ad);
		ml[2]=add(ml[2],ad);
		ml[3]=add(ml[3],ad);
		ml[4]=add(ml[4],ad);
		ml[5]=add(ml[5],ad);
		ml[6]=add(ml[6],ad);
		ml[7]=add(ml[7],ad);
	}
	fl=(unsigned*)(ans+0);
	as2=mul(as2,mul(mul(mul(fl[0],fl[1]),mul(fl[2],fl[3])),mul(mul(fl[4],fl[5]),mul(fl[6],fl[7]))));
	fl=(unsigned*)(ans+1);
	as2=mul(as2,mul(mul(mul(fl[0],fl[1]),mul(fl[2],fl[3])),mul(mul(fl[4],fl[5]),mul(fl[6],fl[7]))));
	fl=(unsigned*)(ans+2);
	as2=mul(as2,mul(mul(mul(fl[0],fl[1]),mul(fl[2],fl[3])),mul(mul(fl[4],fl[5]),mul(fl[6],fl[7]))));
	fl=(unsigned*)(ans+3);
	as2=mul(as2,mul(mul(mul(fl[0],fl[1]),mul(fl[2],fl[3])),mul(mul(fl[4],fl[5]),mul(fl[6],fl[7]))));
	fl=(unsigned*)(ans+4);
	as2=mul(as2,mul(mul(mul(fl[0],fl[1]),mul(fl[2],fl[3])),mul(mul(fl[4],fl[5]),mul(fl[6],fl[7]))));
	fl=(unsigned*)(ans+5);
	as2=mul(as2,mul(mul(mul(fl[0],fl[1]),mul(fl[2],fl[3])),mul(mul(fl[4],fl[5]),mul(fl[6],fl[7]))));
	fl=(unsigned*)(ans+6);
	as2=mul(as2,mul(mul(mul(fl[0],fl[1]),mul(fl[2],fl[3])),mul(mul(fl[4],fl[5]),mul(fl[6],fl[7]))));
	fl=(unsigned*)(ans+7);
	as2=mul(as2,mul(mul(mul(fl[0],fl[1]),mul(fl[2],fl[3])),mul(mul(fl[4],fl[5]),mul(fl[6],fl[7]))));
	}
	as=mul(as,as2);
	as=mon_out(as);
	for(int i=n+1;i<=N;i++)
		as=1ull*as*i%p;
	printf("%u\n",as);
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		int n,p;
		scanf("%d%d",&n,&p);
		solve(n,p);
	}
	return 0;
}