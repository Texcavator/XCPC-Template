# 图论

[toc]

## 最短路

### Dijkstra

时间复杂度 $O(nlogn)$

```cpp
vector<int> dist(n + 1, INF);
vector<bool> st(n + 1);
auto dijkstra = [&](int start)
{
    dist[start] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> pq;
    pq.push({0, start});
    while (pq.size())
    {
        auto t = pq.top(); pq.pop();
        int distance = t.first, ver = t.second;
	if (st[ver]) continue;
	st[ver] = true;
        for (int i = 0; i < g[ver].size(); i ++ )
        {
            int j = g[ver][i];
            if (dist[j] > dist[ver] + w[i])
            {
                dist[j] = dist[ver] + w[i];
                pq.push({dist[j], j});
            }
        }
    }
};
```

### SPFA

时间复杂度 $O(n^2)$

处理有负权边的情况

```cpp
int spfa() // 返回起点到终点的最短距离
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    queue<int> q; q.push(1);
    st[1] = true; // 记录队中现在有哪些点
 
    while (q.size())
    {
        int t = q.front(); // 取出队头
        q.pop();
 
        st[t] = false; // 取出的点不在队中
 
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j]) // 更新的点不在队中就入队
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    return dist[n];
}
```

### Floyd

时间复杂度 $O(n^3)$

可以处理负权边

```cpp
void floyd()
{
    for (int k = 1; k <= n; k ++ )
    {
        for (int i = 1; i <= n; i ++ )
        {
            for (int j = 1; j <= n; j ++ )
            {
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
            }
        }
    }
}
```

## 拓扑排序

利用拓扑排序判断无向图中环上的点：将度为1的点入队，每次取出队头，将邻接点度数-1，邻接点度数为1则入队，直至队空，所有度>1的点都在环上

**但只能判断是否在环上，不能判断是否在同一个环上，如需判断是否在同一环上请使用缩点**

```cpp
queue<int> q;
for (int i = 1; i <= n; i ++ )
    if (ind[i] == 0) q.push(i);
while (q.size())
{
    auto t = q.front(); q.pop();
    for (int i = 0; i < g[t].size(); i ++ )
    {
        int j = g[t][i];
        ind[j] -- ;
        if (ind[j] == 0) q.push(j);
    }
}
```

## 树的直径

### DFS

不支持处理负权边 可求直径路径

```cpp
// 传入图 返回 { 直径长度 { 直径端点1, 直径端点2 } }
auto getdia = [&](vector<vector<int>> &g)
{
	vector<int> dist(n + 1);
	int d1 = 1, d2;
	function<void(int, int, int&)> dfs = [&](int u, int fa, int &d)
	{
		for (int i = 0; i < g[u].size(); i ++ )
		{
			int j = g[u][i];
			if (j == fa) continue;
			dist[j] = dist[u] + 1;
			if (dist[j] > dist[d]) d = j;
			dfs(j, u, d);
		}
	};
	dfs(1, 0, d1);
	d2 = d1;
	dist[d1] = 0;
	dfs(d1, 0, d2);
	return make_pair(dist[d2], make_pair(d1, d2));
};
```

## 树的重心

```cpp
int n, sz[MAXN], mss[MAXN]; // n：总结点数（请从外部传入），sz：树的大小，mss：最大子树大小
vector<int> ctr; // 重心
void dfs(int p, int fa = 0) // 找重心
{
    sz[p] = 1, mss[p] = 0;
    for (auto [to, w] : edges[p])
        if (to != fa)
        {
            dfs(to, p);
            mss[p] = max(mss[p], sz[to]);
            sz[p] += sz[to];
        }
    mss[p] = max(mss[p], n - sz[p]);
    if (mss[p] <= n / 2) ctr.push_back(p);
}
```

### 树形dp

支持处理负权边 不可求直径路径

```cpp
void dfs(int u = 1, int fa = 0)
{
    for (int v : g[u])
    {
        if (v == fa) continue;
        dfs(v, u);
        zj = max(zj, dp[u] + dp[v] + 1); // 如为有权边，把1换成权值即可
        dp[u] = max(dp[u], dp[v] + 1); // 如为有权边，把1换成权值即可
    }
}
```

## 树的重心

```cpp
int n, sz[MAXN], mss[MAXN]; // n：总结点数（请从外部传入），sz：树的大小，mss：最大子树大小
vector<int> ctr; // 重心
void dfs(int p, int fa = 0) // 找重心
{
    sz[p] = 1, mss[p] = 0;
    for (auto [to, w] : edges[p])
        if (to != fa)
        {
            dfs(to, p);
            mss[p] = max(mss[p], sz[to]);
            sz[p] += sz[to];
        }
    mss[p] = max(mss[p], n - sz[p]);
    if (mss[p] <= n / 2) ctr.push_back(p);
}
```

## 最近公共祖先LCA

### 倍增

```cpp
struct LCA
{
	// 修改maxn 建图后dfs() 即可使用
	const static int maxn = 5e5 + 10;
	struct Graph
	{
		int n; // 点数
		vector<vector<int>> g;
		vector<int> dep;
		vector<vector<int>> fa;
		Graph(int n) : n(n), g(n + 1), dep(n + 1), fa(n + 1, vector<int>(21, 0)) {};

		// 新建单向边
		void add_edge(int from, int to)
		{
			g[from].push_back(to);
		}
		// 新建双向边
		void add(int u, int v)
		{
			add_edge(u, v);
			add_edge(v, u);
		}
		// 预处理
		void dfs(int u, int father)
		{
		    dep[u] = dep[father] + 1;
		    fa[u][0] = father;
		    for (int i = 1; (1 << i) <= dep[u]; i ++ ) fa[u][i] = fa[fa[u][i - 1]][i - 1];
		    for (int i = 0; i < g[u].size(); i ++ )
		    {
		        int v = g[u][i];
		        if(v != father) dfs(v,u);
		    }
		}   
	} G;
	int n;
	LCA(int n) : n(n), G(n) {};

	// 返回ab的lca
	int query(int a, int b)
	{
	    if (G.dep[a] < G.dep[b]) swap(a, b); // 把深度大的调到a
	    for (int k = 20; k >= 0; k -- ) // 把两个结点调到同一层
	        if (G.dep[G.fa[a][k]] >= G.dep[b]) a = G.fa[a][k];
	    if (a == b) return a;

	    for (int k = 20; k >= 0; k -- ) // 两个点同时往上跳
	        if (G.fa[a][k] != G.fa[b][k])
	        {
	            a = G.fa[a][k];
	            b = G.fa[b][k];
	        }
	    return G.fa[a][0];
	}
};
```

### 树链剖分

见树链剖分部分

### 约束RMQ

时间复杂度：预处理 $O(n)$ ，查询 $O(1)$

```cpp
struct LCA
{
	// 修改maxn 建图后init() 即可使用
	const static int maxn = 5e5 + 10;
	struct Graph
	{
		int n; // 点数
		vector<vector<PII>> g;
		Graph(int n) : n(n), g(n + 1) {};

		// 新建单向边
		void add_edge(int from, int to, int w)
		{
			g[from].push_back({to, w});
		}
		// 新建双向边
		void add(int u, int v, int l)
		{
			add_edge(u, v, l);
			add_edge(v, u, l);
		}
	} G;
	int n, idx;
	vector<int> dep, dis, seq, fir, _log;
	vector<vector<int>> f;
	LCA(int n) : n(n), G(n), dep(n + 1), dis(n + 1), seq(maxn << 1), fir(n + 1), f(maxn << 1, vector<int>(20)),
				_log(maxn << 1), idx(0) {};

	void dfs(int now, int fa)
    {
        seq[++idx] = now; fir[now] = idx;
        dep[now] = dep[fa] + 1;
        for (auto [to, w] : G.g[now])
            if (to != fa)
                dis[to] = dis[now] + w, dfs(to, now), seq[++idx] = now;
    }
    int mindep(int &x, int &y)
    {
        return dep[x] < dep[y] ? x : y;
    }
    void init(int root)
    {
		dfs(root, 0);
        _log[0] = -1;
        for (int i = 1; i <= idx; i ++ ) _log[i] = _log[i >> 1] + 1;
        for (int i = 1; i <= idx; i ++ ) f[i][0] = seq[i];
        for (int j = 1; j < 20; j ++ )
            for (int i = 1; i + (1 << j) - 1 <= idx; i ++ )
                f[i][j] = mindep(f[i][j - 1], f[i + (1 << j - 1)][j - 1]);
    }
	// 询问xy的lca
    int query(int x, int y)
    {
        x = fir[x]; y = fir[y];
        if (x > y) swap(x, y);
        int k = _log[y - x + 1];
        return mindep(f[x][k], f[y - (1 << k) + 1][k]);
    }
	// 询问xy的距离
    int getdis(int x, int y)
    {
        if (x == 0 || y == 0) return 0;
        return dis[x] + dis[y] - 2LL * dis[query(x, y)];
    }
};
```

## 缩点

```cpp
struct SCC
{
    int n, m; // 点数和边数
    vector<vector<int>> G, g; // 原图和新图
    vector<int> stk;
    vector<int> dfn, low, bel, ind;
	vector<PII> edge;
    int cur, cnt;
    SCC() {}
    SCC(int n, int m)
	{
        init(n, m);
    }
    
    void init(int n, int m)
	{
        this->n = n; this->m = m;
        G.assign(n + 1, {}); dfn.assign(n + 1, -1);
        low.resize(n + 1); bel.assign(n + 1, -1);
		edge.resize(m + 1); stk.clear();
        cur = cnt = 1;
    }
    void addEdge(int u, int v)
	{
        G[u].push_back(v);
    }
    void dfs(int x)
	{
        dfn[x] = low[x] = cur++;
        stk.push_back(x);
        for (auto y : G[x])
		{
            if (dfn[y] == -1)
			{
                dfs(y);
                low[x] = min(low[x], low[y]);
            }
			else if (bel[y] == -1)
			{
                low[x] = min(low[x], dfn[y]);
            }
        }
        if (dfn[x] == low[x])
		{
            int y;
            do {
                y = stk.back();
                bel[y] = cnt;
                stk.pop_back();
            } while (y != x);
            cnt++;
        }
    }
	// 缩点
    void work()
	{
        for (int i = 1; i <= n; i ++ )
		{
            if (dfn[i] == -1) dfs(i);
        }
    }
	// 建新图
	void build()
	{
		ind.assign(cnt + 1, 0);
		g.resize(cnt + 1);
		for (int i = 1; i <= m; i ++ )
		{
			int a = bel[edge[i].first];
			int b = bel[edge[i].second];
			if (a != b)
			{
				g[a].push_back(b);
				ind[b] ++ ;
			}
		}
	}
};
```

## 割点 割边

```cpp
struct EBCC
{
	// 建图后 work1()求割点 work2()求桥
	const static int N = 1e5 + 10, M = 1e6 + 10;
	int head[N], edge[M << 1], Next[M << 1], tot;
	int dfn[N], low[N], n, m, num = 0, root = 0;
	bool cut[N], bridge[M << 1];
	EBCC(int n, int m) : n(n), m(m), tot(0)
	{
		init();
	}

	void init()
	{
		for (int i = 0; i <= n; i ++ ) head[i] = dfn[i] = low[i] = cut[i] = 0;
		for (int i = 0; i <= m * 2; i ++ ) edge[i] = Next[i] = bridge[i] = 0;
	}
	// 建边
	void add_edge(int a, int b)
	{
		edge[++tot] = b;
		Next[tot] = head[a];
		head[a] = tot;
	}
	// 割点
	void Tarjan1(int x)
	{
		dfn[x] = low[x] = ++num; 
		int flag = 0;
		for (int i = head[x]; i; i = Next[i])
		{
			int y = edge[i]; 
			if (!dfn[y])
			{
				Tarjan1(y);
				low[x] = min(low[x], low[y]);
				if (low[y] >= dfn[x])
				{
					flag++;
					if (x != root || flag > 1) cut[x] = true;
				}
			}
			else low[x] = min(low[x], dfn[y]);
		}
	}
	// 割边/桥
	void Tarjan2(int x, int Edge)
	{
		dfn[x] = low[x] = ++num;
		for (int i = head[x]; i; i = Next[i])
		{
			int y = edge[i];
			if (!dfn[y])
			{
				Tarjan2(y, i);
				low[x] = min(low[x], low[y]);
				if (low[y] > dfn[x]) bridge[i] = bridge[i ^ 1] = true;
			}
			else if (i != (Edge ^ 1)) low[x] = min(low[x], dfn[y]);
		}
	}
	// 调用此函数求割点 调用后cut[u]表示u是否为割点
	void work1()
	{
		for (int i = 1; i <= n; i ++ )
		{
			if (!dfn[i])
			{
				root = i;
				Tarjan1(i);
			}
		}
	}
	// 调用此函数求桥 调用后bridge[e]表示边e是否为桥
	void work2()
	{
		for (int i = 1; i <= n; i ++ )
		{
			if (!dfn[i]) Tarjan2(i, 0);
		}
	}
};
```

## 二分图

判断二分图的充要条件：连通图不含基数环

### 判断

染色法

```cpp
bool flag = true;
for (int i = 1; i <= n; i ++ )
{
    if (!color[i]) // 未被染色则开始遍历
    {
        if (!dfs(i, 1))
        {
            flag = false;
            break;
        }
    }
}
bool dfs(int u, int c)
{
    color[u] = c; // 对该点进行染色
 
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!color[j])  if (!dfs(j, 3 - c)) return false;
        else if (color[j] == c) return false; // 已染色的点判断是否合法
    }
 
    return true;
}
```

### 最大匹配数

直接跑最大流

## 最小生成树

### Kruskal

适合稀疏图，时间复杂度 $O(ElogV)$

```cpp
struct Edge
{
    int a, b, w;
    bool operator< (const Edge &W) const
    {
        return w < W.w;
    }
} edges[M];
int find(int x) // 判断x属于哪一个点集
{
    if (x != p[x]) p[x] = find(p[x]);
    return p[x];
}
int kruskal() // 返回最小生成树的权重和
{
    sort(edges, edges + m); // 所有边按权重排序
    for (int i = 1; i <= n; i ++ ) p[i] = i; // 所有点单独占一个点集
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ ) // 从小到大遍历每条边
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        a = find(a), b = find(b);
        if (a != b) // 判断ab在不在同一个点集
        {
            p[a] = b; // 合并到同一点集
            res += w;
            cnt ++ ;
        }
    }
    if (cnt < n - 1) return INF; // 不是连通图
    return res;
}
```

### Prim

适合稠密图，时间复杂度 $O(V^2)$

```cpp
int prim() // 返回最小生成树的权重和
{
    vector<int> dist(n + 1, INF);
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ ) // 找到距离生成树集合距离最短的点
            if (!st[j] && (t == -1 || dist[t] > dist[j])) t = j;
        if (i && dist[t] == INF) return INF; // 距离最短的点距离时INF
        if (i) res += dist[t];
        st[t] = true;
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }
    return res;
}
```

## 最小环

### Dijkstra

枚举所有边，每一次求删除一条边之后对这条边的起点跑一次 Dijkstra，设 $u$ 和 $v$ 之间有一条边长为 $w$ 的边，$dis(u,v)$ 表示删除 $u$ 和 $v$ 之间的连边之后，$u$ 和 $v$ 之间的最短路。

那么无向图中的最小环是 $dis(u,v)+w$。

注意若是在有向图中求最小环是 $dis(v,u)+w$。

时间复杂度 $O(m(n+m)\log n)$。

### Floyd

时间复杂度：$O(n^3)$

```cpp
#include <bits/stdc++.h>
using namespace std;

signed main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (i != j) d[i][j] = 10000000;
    ans = 10000000;
    for (int i = 1; i <= m; i++)
    {
        cin >> a >> b >> w;
        if (a == b) continue;
        if (g[a][b] == 0) g[a][b] = w;
        g[a][b] = min(g[a][b], w);
        g[b][a] = g[a][b];
        d[a][b] = g[a][b];
        d[b][a] = g[a][b]; // 存无向图
    }
    for (int k = 1; k <= n; k++)
    {
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                if (i != j && g[i][k] > 0 && g[k][j] > 0) ans = min(ans, d[i][j] + g[i][k] + g[k][j]);
                if (d[i][k] + d[k][j] < d[i][j]) d[i][j] = d[i][k] + d[k][j];
            }
        }
    }
    if (ans != 10000000) cout << ans;
    else cout << "No solution.";
}
```

## 2-sat

解决类似 $(¬a∨b)∧(a∨c)∧(¬c∨¬b)$ 的合法方案解问题

思路：将 $a∨b$ 理解为选了 $a$ 就不能选 $b$，也就是选了 $a$ 就一定要选 $¬b$，选了 $b$ 就一定要选 $¬a$，将 $a$ 和 $¬b$ 连边，$b$ 和 $¬a$ 连边，在同一个连通分量里的认为等价，进行缩点后判断是否合法

## 树链剖分

```cpp
struct Tree_Cut
{
	// 建图后调用work()
	/*
	- `fa[u]` 结点 u 的父亲结点
	- `dep[u]` 结点 u 的深度
	- `sz[u]` 以结点 u 为根的子树的结点个数
	- `son[u]` 结点 u 的重儿子
	- `top[u]` 结点 u 所在链的顶端结点
	- `dfn[u]` 结点 u 在 dfs 中的执行顺序，同时也是树链剖分后的新编号，可以理解为dfs序的映射
	- `id[u]` dfn 标号 u 对应的结点编号，有 `id[dfn[u]] == u`
	*/
    struct Segment_Tree
    {
        struct node
        {
            int val, tag;
            node() : val(0), tag(0) {};
        };
        vector<node> tr;
        int n, N;
        vector<int> a;
        Segment_Tree(int n) : n(n), N(1), tr((n + 1) << 2), a(n + 1) {};

        void build()
        {
            for (; N <= n + 1; N <<= 1) ;
            for (int i = N + 1; i <= N + n; i ++ ) tr[i].val = a[i - N];
            for (int i = N - 1; i >= 1; i -- ) tr[i].val = tr[i << 1].val + tr[i << 1 | 1].val;
        }
        // 单点修改
        void modify(int x, int k)
        {
            for (x += N; x; x >>= 1) tr[x].val += k;
        }
        // 区间修改
        void modify(int s, int t, int k)
        {
            int lNum = 0, rNum = 0, nNum = 1;
            for (s = N + s - 1, t = N + t + 1; s ^ t ^ 1; s >>= 1, t >>= 1, nNum <<= 1)
            {
                tr[s].val += k * lNum; tr[t].val += k * rNum;
                if (~s & 1)
                {
                    tr[s ^ 1].tag += k; tr[s ^ 1].val += k * nNum;
                    lNum += nNum;
                }
                if (t & 1)
                {
                    tr[t ^ 1].tag += k; tr[t ^ 1].val += k * nNum;
                    rNum += nNum;
                }
            }
            for (; s; s >>= 1, t >>= 1)
            {
                tr[s].val += k * lNum; tr[t].val += k * rNum;
            }
        }
        // 区间查询
        int query(int s, int t)
        {
            int lNum = 0, rNum = 0, nNum = 1;
            int ans = 0;
            for (s = N + s - 1, t = N + t + 1; s ^ t ^ 1; s >>= 1, t >>= 1, nNum <<= 1)
            {
                if (tr[s].tag) ans += tr[s].tag * lNum;
                if (tr[t].tag) ans += tr[t].tag * rNum;
                if (~s & 1)
                {
                    ans += tr[s ^ 1].val;
                    lNum += nNum;
                }
                if (t & 1)
                {
                    ans += tr[t ^ 1].val;
                    rNum += nNum;
                }
            }
            for (; s; s >>= 1, t >>= 1)
            {
                ans += tr[s].tag * lNum;
                ans += tr[t].tag * rNum;
            }
            return ans;
        }
    };
	Segment_Tree sg;
	int n, cnt;
	vector<vector<int>> g;
	vector<int> fa, dep, sz, son, top, dfn, id;
	Tree_Cut(int n) : n(n), cnt(0), g(n + 1), fa(n + 1), dep(n + 1), sz(n + 1), son(n + 1),
				top(n + 1), dfn(n + 1), id(n + 1) , sg(n) {};

	void dfs1(int u, int father, int depth) // u: 当前结点  fa: 父结点  depth: 当前深度
	{
		fa[u] = father; // 更新当前结点父结点
		dep[u] = depth; // 更新当前结点深度
		sz[u] = 1; // 子树大小初始化为1
		for (int i = 0; i < g[u].size(); i ++ )
		{
			int j = g[u][i]; // 子结点编号
			if (j == father) continue;
			dfs1(j, u, depth + 1);
			sz[u] += sz[j]; // 用子结点的sz更新父结点的sz
			if (sz[j] > sz[son[u]]) son[u] = j; // 更新重子结点
		}
	}
	void dfs2(int u, int tt) // u: 当前结点  tt: 重链顶端结点
	{
		top[u] = tt; // 更新当前结点所在重链顶端
		dfn[u] = ++ cnt; // 更新dfs序
		id[cnt] = u; // 更新dfs序的映射
		if (!son[u]) return; // 叶子结点 直接退出
		// 优先遍历重子结点 目的是保证链上各个结点的dfs序连续
		// 当前结点的重子结点和当前结点在同一条链上 所以链的顶端都是tt
		dfs2(son[u], tt); 
		for (int i = 0; i < g[u].size(); i ++ )
		{
			int j = g[u][i]; // 子结点编号
			if (j == son[u] || j == fa[u]) continue; // 遇到重子结点或者父结点就跳过
			dfs2(j, j); // j点位于轻链顶端 它的top必然是本身
		}
	}
	void work(int root = r)
	{
		dfs1(root, 0, 0);
		dfs2(root, root);
	}
	// 返回x-y最短路径点权和
	int sum_path(int x, int y) 
	{
		int ans = 0;
		while (top[x] != top[y]) // 让x和y跳到同一条链上
		{
			if (dep[top[x]] < dep[top[y]]) swap(x, y);
			ans = (ans + sg.query(dfn[top[x]], dfn[x]));
            x = fa[top[x]];
		}
		if (dep[x] > dep[y]) swap(x, y);
        ans = (ans + sg.query(dfn[x], dfn[y]));
        return ans;
	}
	// 把x与y的最短路上所有点的权值都加上c
	void update_path(int x, int y, int c) 
	{
        c %= p;
        while (top[x] != top[y])
        {
            if (dep[top[x]] < dep[top[y]]) swap(x, y);
            sg.modify(dfn[top[x]], dfn[x], c);
            x = fa[top[x]];
        }
        if (dep[x] > dep[y]) swap(x, y);
        sg.modify(dfn[x], dfn[y], c);
	}
    // 返回x子树点权和
    int sum_son(int x)
    {
        return sg.query(dfn[x] , dfn[x] + sz[x] - 1);
    }
    // 把x子树所有点权加c
    void update_son(int x, int c)
    {
        sg.modify(dfn[x] , dfn[x] + sz[x] - 1 , c);
    }
    // 求u和v的lca
	int lca(int u, int v) 
	{
		while (top[u] != top[v]) // 如果u和v不在同一条链上就一直让深度大的点往上跳
		{
			if (dep[top[u]] > dep[top[v]]) u = fa[top[u]];
			else v = fa[top[v]];
		}
		return dep[u] > dep[v] ? v : u; // 深度小的结点就是lca
	}
};
```

## 树上启发式合并

```cpp
/*
- `sz[u]` 以 u 为根的子树的结点数量
- `son[u]` 结点 u 的重子结点
- `col[u]` 结点 u 的颜色
- `L[u]` 结点 u 的 dfs 序
- `R[u]` 以 u 为根的子树中结点 dfs 序的最大值
- `id[u]` L 标号 u 对应的结点编号，有 `id[L[u]] == u`
- `cnt[u]` 颜色 u 的出现次数
- `totcol` 目前出现过的颜色个数
*/
void dfs1(int u, int fa) // u: 当前结点  fa: 父结点
{
	L[u] = ++ totdfn; // 更新u的dfs序
	Node[totdfn] = u; // 更新dfs序的映射
	sz[u] = 1; // 初始化子树大小为1
	for (int i = 0; i < g[u].size(); i ++ )
	{
		int j = g[u][i]; // 子结点编号
		if (j == fa) continue;
		dfs1(j, u);
		sz[u] += sz[j]; // 用子结点的sz更新父结点的sz
		if (sz[j] > sz[son[u]]) son[u] = j; // 更新重子结点
	}
	R[u] = totdfn; // 更新当前子树中dfs序的最大值
}

void dfs2(int u, int fa, bool keep) // u: 当前结点  fa: 父结点  keep: 此次遍历计算的答案是否保留
{
	// 计算轻子结点的答案
	for (int i = 0; i < g[u].size(); i ++ )
	{
		int j = g[u][i]; // 子结点编号
		if (j == fa || j == son[u]) continue; // 遇到重子结点或者父结点就跳过
		dfs2(j, u, false); // 继续计算轻子结点的答案且不保留
	}

	if (son[u]) dfs2(son[u], u, true); // 计算重儿子答案并保留计算过程中的数据（用于继承）

	for (int i = 0; i < g[u].size(); i ++ )
	{
		int j = g[u][i]; // 子结点编号
		if (j == fa || j == son[u]) continue; // 遇到重子结点或者父结点就跳过

		// 子树结点的 DFS 序构成一段连续区间，可以直接遍历
		for (int k = L[j]; k <= R[j]; k ++ ) add(id[k]); // 加上轻子结点对答案的贡献
	}
	add(u); // 加上当前子树根结点对答案的贡献
	ans[u] = totcol;
	if (keep == false) // 如果当前计算的答案不保留 就删去
		for (int i = L[u]; i <= R[u]; i ++ ) del(id[i]);
}

```

## 虚树

适用于解决一棵树中只需要用到少部分点的时候，将需要用到的点提出来单独建一棵树

```cpp
struct edge
{
	int to, next;
	int val;
};

struct Virtual_Tree
{
	int n; // 点数
	int dfn[N]; // dfs序
	int dep[N]; // 深度
	int fa[N][25], m[N];
	int num; // 关键点数
	vector<int> lst; // 关键点
	bool query[N]; // 是否为关键点
	int top, cnt1 = 1, cnt2 = 1, dfscnt = 1;
	int stk[MAXN];
	int head1[N], head2[N];
	struct edge edge1[N << 1], edge2[N << 1]; // 原树和虚树

	/* 在下方添加需要的信息定义 */
	int minv[N];
	/***************************/

	// 初始化
	void init()
	{
		for (int i = 1; i <= n; i ++ )
		{
			dfn[i] = dep[i] = m[i] = query[i] = 0;
			for (int j = 0; j < 24; j ++ ) fa[i][j] = 0;
		}
	}

	// 原树建边
	void add1(int x, int y, int v)
	{
		edge1[cnt1].next = head1[x];
    	edge1[cnt1].to = y;
    	edge1[cnt1].val = v;
    	head1[x] = cnt1 ++ ;
	}

	// 虚树建边
	void add2(int x, int y)
	{
    	edge2[cnt2].next = head2[x];
    	edge2[cnt2].to = y;
    	head2[x] = cnt2 ++ ;
	}

	// 预处理原树基本信息
	void dfs1(int pos)
	{
    	int k;
    	for (k = 0; fa[pos][k]; k ++ ) fa[pos][k + 1] = fa[fa[pos][k]][k];
    	m[pos] = k;
    	dfn[pos] = dfscnt++;
    	for (int i = head1[pos]; i; i = edge1[i].next)
    	{
    	    int to = edge1[i].to;
    	    if (!dfn[to])
    	    {
    	        dep[to] = dep[pos] + 1;
    	        fa[to][0] = pos;
				/* 在下方处理需要的信息 */
    	        minv[to] = min(minv[pos], edge1[i].val);
				/***********************/
    	        dfs1(to);
    	    }
    	}
	}

	// 倍增求lca
	int lca(int x, int y)
	{
    	if (dep[x] < dep[y]) swap(x, y);
		for (int i = m[x]; i > -1; i -- )
		{
    		if (dep[fa[x][i]] >= dep[y]) x = fa[x][i];
		}
    	if (x == y) return x;
		for (int i = m[x]; i > -1; i -- )
		{
    		if (fa[x][i] != fa[y][i])
    		{
    		    x = fa[x][i];
    		    y = fa[y][i];
    		}
		}
    	return fa[x][0];
	}

	// 建虚树 关键点存在lst里 lst大小为k 下标从0开始
	void build(int k, vector<int>& lst)
	{
		// 按照dfs序排序规则
		auto cmp = [&](int x1, int x2)
		{
			return dfn[x1] < dfn[x2];
		};
		sort(lst.begin(), lst.end(), cmp);
		stk[top = 1] = lst[0];
		for (int i = 1; i < k; i ++ )
		{
			int now = lst[i];
			int lc = lca(now, stk[top]);
			while (1)
			{
				if (dep[lc] >= dep[stk[top - 1]])
                {
                    if (lc != stk[top])
                    {
                        add2(lc, stk[top]);
                        if (lc != stk[top - 1]) stk[top] = lc;
                        else top -- ;
                    }
                    break;
                }
                else
                {
                    add2(stk[top - 1], stk[top]);
                    top -- ;
                }
			}
			stk[++ top] = now;
		}
		while (-- top) add2(stk[top], stk[top + 1]);
	}

	// 树形dp计算答案
	int dfs2(int u)
	{
		/* 下方填写计算答案代码逻辑 */

		/**************************/

		// 清空虚树
		query[u] = false;
		head2[u] = 0;
		return res;
	}

	// 在下方填写解题逻辑
	void solve()
	{
		/* 思路 */

		/********/

		// 每次建虚树后需要清空
		cnt2 = 1;
		lst.clear();
	}
} vtr;

```

## 树哈希

解决树同构问题

```cpp
struct Tree_Hash
{
    // 建图后可直接使用 多棵树共用时需调用init()
    typedef unsigned long long ull;
    const ull mask = chrono::steady_clock::now().time_since_epoch().count();
    int n;
    vector<ull> hash;
    vector<vector<int>> g;
    set<ull> trees; // 所有子树的非同构树哈希值
    vector<ull> root; // root[i] 以i为根的树哈希值
    Tree_Hash() {}
    Tree_Hash(int n) : n(n), hash(n + 1), g(n + 1), root(n + 1)
    {
        trees.clear();
    }

    // 多棵树使用同一个结构体时初始化
    // 如果是判断多棵树是否同构 一定要用同一个结构体！！！否则随机数初始化会不一样
    void init(int sz)
    {
        n = sz;
        hash.clear(); hash.assign(n + 1, 0);
        g.clear(); g.resize(n + 1);
        root.clear(); root.assign(n + 1, 0);
    }
    ull shift(ull x)
    {
        x ^= mask; x ^= x << 13;
        x ^= x >> 7; x ^= x << 17;
        x ^= mask;
        return x;
    }
    // 求以x为根的哈希值 同时存储所有子树的哈希值进入trees
    void getHash(int x, int fa)
    {
        hash[x] = 1;
        for (int i : g[x])
        {
            if (i == fa) continue;
            getHash(i, x);
            hash[x] += shift(hash[i]);
        }
        trees.insert(hash[x]);
    }
    // 换根dp求出以所有结点为根时的哈希值
    void dp_getHash(int x, int fa)
    {
        for (int i : g[x])
        {
            if (i == fa) continue;
            root[i] = hash[i] + shift(root[x] - shift(hash[i]));
            dp_getHash(i, x);
        }
    }
    // 无根树求树哈希值
    ull noRootHash(int rt = 1)
    {
        getHash(rt, 0);
        root[rt] = hash[rt];
        dp_getHash(rt, 0);
        ull res = 1;
        for (int i = 1; i <= n; i ++ ) res += shift(root[i]);
        return res;
    }
};
```

## 网络流

### 最大流

#### Dinic

```cpp
struct Net
{
	// 定义后记得更新ST dinic()即可得最大流
	const static int maxn = 210, maxm = 5010;
	int n, m, S, T; // 点数 边数 源点 汇点
	int h[maxn], e[maxm << 1], f[maxm << 1], ne[maxm << 1], idx;
	int d[maxn], pre[maxn], cur[maxn]; // d[i]:每个点的层数，源点为0 pre[i]:一条增广路径的前缀边 cur[i]:当前弧优化
	Net(int n) :  n(n), idx(0)
	{
		init();
	}

	void init()
	{
		for (int i = 0; i <= n; i ++ ) h[i] = -1;
	}
	void add(int a, int b, int c)
	{
		e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
		e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
	}
	bool bfs()
	{
		queue<int> q;
		for (int i = 1; i <= n; i ++ ) d[i] = -1;
		q.push(S), d[S] = 0, cur[S] = h[S]; // 初始化
		while (q.size())
		{
			auto t = q.front();
			q.pop();
			for (int i = h[t]; i != -1; i = ne[i])
			{
				int ver = e[i];
				if (d[ver] == -1 && f[i]) // 这个点没访问过且连边还有容量
				{
					d[ver] = d[t] + 1; // 更新该点层数
					cur[ver] = h[ver]; // 当前弧优化
					if (ver == T) return true; // 遇到汇点
					q.push(ver);
				}
			}
		}
		return false; // 没有增广路
	}
	int find(int u, int limit) // u是当前点 limit是流入这个点的流量 函数返回从这个点最多能流出的流量
	{
		if (u == T) return limit;
		int flow = 0; // 从当前点流出的最大流量
		for (int i = cur[u]; i != -1 && flow < limit; i = ne[i])
		{
			cur[u] = i; // 当前弧优化 能访问到第i条边说明第i条边之前的边都已经不能用了
			int ver = e[i];
			if (d[ver] == d[u] + 1 && f[i])
			{
				int t = find(ver, min(f[i], limit-  flow));
				if (!t) d[ver] = -1; // 没有流量流出 说明这个点已经废了
				else f[i] -= t, f[i ^ 1] += t, flow += t;
			}
		}
		return flow;
	}
	// 计算最大流
	int dinic()
	{
		int r = 0, flow;
		while (bfs())
			while (flow = find(S, INF))
				r += flow;
		return r;
	}
};
```

#### 预流推进

```cpp
struct HLPP 
{
	// 定义后记得修改st 建边后调用hlpp()返回最大流
	const static int maxn = 200010, maxm = 600010;
	int n, m, s, t;
	struct qxx
	{
		int nex, t;
		int v;
	};
	qxx e[maxm * 2 + 1];
	int h[maxn], cnt = 1;
	int ht[maxn + 1];	// 高度;
	int ex[maxn + 1];	// 超额流;
	int gap[maxn];		// gap 优化. gap[i] 为高度为 i 的节点的数量
	stack<int> B[maxn]; // 桶 B[i] 中记录所有 ht[v]==i 的v
	int level;		// 溢出节点的最高高度
	HLPP(int n) : n(n), cnt(1), level(0)
	{
        for (int i = 0; i <= n; i++) h[i] = ht[i] = ex[i] = 0;
        for (int i = 0; i < maxn; i++)
		{
            while (!B[i].empty()) B[i].pop();
            gap[i] = 0;
        }
    }

	void add_path(int f, int t, int v)
	{
		e[++cnt] = qxx{h[f], t, v}, h[f] = cnt;
	}
	void add(int f, int t, int v)
	{
		add_path(f, t, v);
		add_path(t, f, 0);
	}
	int push(int u)
	{
		bool init = u == s; // 是否在初始化
		for (int i = h[u]; i; i = e[i].nex)
		{
			const int &v = e[i].t;
			const int &w = e[i].v;
			// 初始化时不考虑高度差为1
			if (!w || (init == false && ht[u] != ht[v] + 1) || ht[v] == INF) continue;
			int k = init ? w : min(w, ex[u]);
			// 取到剩余容量和超额流的最小值，初始化时可以使源的溢出量为负数。
			if (v != s && v != t && !ex[v]) B[ht[v]].push(v), level = max(level, ht[v]);
			ex[u] -= k, ex[v] += k, e[i].v -= k, e[i ^ 1].v += k; // push
			if (!ex[u]) return 0; // 如果已经推送完就返回
		}
		return 1;
	}
	void relabel(int u)
	{
		ht[u] = INF;
		for (int i = h[u]; i; i = e[i].nex)
			if (e[i].v)
				ht[u] = min(ht[u], ht[e[i].t]);
		if (++ht[u] < n)
		{ // 只处理高度小于 n 的节点
			B[ht[u]].push(u);
			level = max(level, ht[u]);
			++gap[ht[u]]; // 新的高度，更新 gap
		}
	}
	bool bfs_init()
	{
		memset(ht, 0x3f, sizeof(ht));
		queue<int> q;
		q.push(t), ht[t] = 0;
		while (q.size())
		{ // 反向 BFS, 遇到没有访问过的结点就入队
			int u = q.front();
			q.pop();
			for (int i = h[u]; i; i = e[i].nex)
			{
				const int &v = e[i].t;
				if (e[i ^ 1].v && ht[v] > ht[u] + 1)
					ht[v] = ht[u] + 1, q.push(v);
			}
		}
		return ht[s] != INF; // 如果图不连通，返回 0
	}
	// 选出当前高度最大的节点之一, 如果已经没有溢出节点返回 0
	int select()
	{
		while (level > -1 && B[level].size() == 0)
			level--;
		return level == -1 ? 0 : B[level].top();
	}
	// 返回最大流
	int hlpp()
	{
		if (!bfs_init()) return 0; // 图不连通
		memset(gap, 0, sizeof(gap));
		for (int i = 1; i <= n; i++)
			if (ht[i] != INF) gap[ht[i]]++; // 初始化 gap
		ht[s] = n;
		push(s); // 初始化预流
		int u;
		while ((u = select()))
		{
			B[level].pop();
			if (push(u))
			{ // 仍然溢出
				if (!--gap[ht[u]])
					for (int i = 1; i <= n; i++)
						if (i != s && ht[i] > ht[u] && ht[i] < n + 1)
							ht[i] = n + 1; // 这里重贴成 n+1 的节点都不是溢出节点
				relabel(u);
			}
		}
		return ex[t];
	}
};
```

### 最小费用最大流 / 最小费用可行流

```cpp
class Graph
{
public:
	const static int V = 2000, M = 1e5 + 10;
    int n, m;
    int top, to[M << 1], fw[M << 1], ct[M << 1];
    vector<int> g[V];
    Graph() { top = 1; }
    void add(int x, int y, int f, int c)
    {
        g[x].push_back(++top);
        to[top] = y, fw[top] = f, ct[top] = c;
    }
    void Add(int x, int y, int f, int c)
    {
        add(x, y, f, c), add(y, x, 0, -c);
    }
};
class zkwMCMF : public Graph
{
public:
    int s, t;
    int fans, cans; // 最大流流量 和 最小费用
    int dep[V];
    bool vis[V];
    deque<int> q;
    bool spfa()
    {
        for (int i = 1; i <= n; i++) vis[i] = 0, dep[i] = INF;
        q.push_back(t), vis[t] = 1, dep[t] = 0;
        while (q.size())
        {
            int x = q.front();
            q.pop_front(), vis[x] = 0;
            for (auto i : g[x])
                if (fw[i ^ 1] && dep[to[i]] > dep[x] - ct[i])
                {
                    dep[to[i]] = dep[x] - ct[i];
                    if (!vis[to[i]])
                    {
                        vis[to[i]] = 1;
                        if (q.size() && dep[to[i]] < dep[q.front()]) q.push_front(to[i]);
                        else q.push_back(to[i]);
                    }
                }
        }

		/* 最小费用最大流 */
        return dep[s] < INF;
		/*****************/

		/* 最小费用可行流 */
		if (dep[s] == INF || dep[s] >= 0) return 0;
		else return 1;
		/*****************/
    }
    int dfs(int x, int F)
    {
        vis[x] = 1;
        if (x == t || !F) return F;
        int f, flow = 0;
        for (auto i : g[x])
            if (!vis[to[i]] && fw[i] && dep[x] - ct[i] == dep[to[i]] && (f = dfs(to[i], min(F, fw[i]))) > 0)
            {
                cans += f * ct[i], fw[i] -= f, fw[i ^ 1] += f, flow += f, F -= f;
                if (!F) break;
            }
        return flow;
    }
    // 求最小费用最大流/可行流调用此函数即可
    // 求最大费用最大流/可行流，需要在建图时将费用取反，最后的最大费用为 -cans
    void mcmf()
    {
        while (spfa())
        {
            vis[t] = 1;
            while (vis[t])
            {
                for (int i = 1; i <= n; i ++ ) vis[i] = 0;
                fans += dfs(s, INF);
            }
        }
    }
} network;
```

## K 短路

**问题描述**

给定一个有 $n$ 个结点，$m$ 条边的有向图，求从 $s$ 到 $t$ 的所有不同路径中的第 $k$ 短路径的长度。

### A \* 算法

A \* 算法定义了一个对当前状态 $x$ 的估价函数 $f(x)=g(x)+h(x)$，其中 $g(x)$ 为从初始状态到达当前状态的实际代价，$h(x)$ 为从当前状态到达目标状态的最佳路径的估计代价。每次取出 $f(x)$ 最优的状态 $x$，扩展其所有子状态，可以用 **优先队列** 来维护这个值。

在求解 $k$ 短路问题时，令 $h(x)$ 为从当前结点到达终点 $t$ 的最短路径长度。可以通过在反向图上对结点 $t$ 跑单源最短路预处理出对每个结点的这个值。

由于设计的距离函数和估价函数，对于每个状态需要记录两个值，为当前到达的结点 $x$ 和已经走过的距离 $g(x)$，将这种状态记为 $(x,g(x))$。

开始我们将初始状态 $(s,0)$ 加入优先队列。每次我们取出估价函数 $f(x)=g(x)+h(x)$ 最小的一个状态，枚举该状态到达的结点 $x$ 的所有出边，将对应的子状态加入优先队列。当我们访问到一个结点第 $k$ 次时，对应的状态的 $g(x)$ 就是从 $x$ 到该结点的第 $k$ 短路。

优化：由于只需要求出从初始结点到目标结点的第 $k$ 短路，所以已经取出的状态到达一个结点的次数大于 $k$ 次时，可以不扩展其子状态。因为之前 $k$ 次已经形成了 $k$ 条合法路径，当前状态不会影响到最后的答案。

当图的形态是一个 $n$ 元环的时候，该算法最坏是 $O(nk\log n)$ 的。但是这种算法可以在相同的复杂度内求出从起始点 $s$ 到每个结点的前 $k$ 短路。

**实现**

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int maxn = 5010;
const int maxm = 400010;
const int inf = 2e9;
int n, m, s, t, k, u, v, ww, H[maxn], cnt[maxn];
int cur, h[maxn], nxt[maxm], p[maxm], w[maxm];
int cur1, h1[maxn], nxt1[maxm], p1[maxm], w1[maxm];
bool tf[maxn];

void add_edge(int x, int y, double z) {
  cur++;
  nxt[cur] = h[x];
  h[x] = cur;
  p[cur] = y;
  w[cur] = z;
}

void add_edge1(int x, int y, double z) {
  cur1++;
  nxt1[cur1] = h1[x];
  h1[x] = cur1;
  p1[cur1] = y;
  w1[cur1] = z;
}

struct node {
  int x, v;

  bool operator<(node a) const { return v + H[x] > a.v + H[a.x]; }
};

priority_queue<node> q;

struct node2 {
  int x, v;

  bool operator<(node2 a) const { return v > a.v; }
} x;

priority_queue<node2> Q;

int main() {
  scanf("%d%d%d%d%d", &n, &m, &s, &t, &k);
  while (m--) {
    scanf("%d%d%d", &u, &v, &ww);
    add_edge(u, v, ww);
    add_edge1(v, u, ww);
  }
  for (int i = 1; i <= n; i++) H[i] = inf;
  Q.push({t, 0});
  while (!Q.empty()) {
    x = Q.top();
    Q.pop();
    if (tf[x.x]) continue;
    tf[x.x] = true;
    H[x.x] = x.v;
    for (int j = h1[x.x]; j; j = nxt1[j]) Q.push({p1[j], x.v + w1[j]});
  }
  q.push({s, 0});
  while (!q.empty()) {
    node x = q.top();
    q.pop();
    cnt[x.x]++;
    if (x.x == t && cnt[x.x] == k) {
      printf("%d\n", x.v);
      return 0;
    }
    if (cnt[x.x] > k) continue;
    for (int j = h[x.x]; j; j = nxt[j]) q.push({p[j], x.v + w[j]});
  }
  printf("-1\n");
  return 0;
}
```

### 可持久化可并堆优化 k 短路算法

**最短路树与任意路径**

**定义**

在反向图上从 $t$ 开始跑最短路，设在原图上结点 $x$ 到 $t$ 的最短路长度为 $dist_x$，建出 **任意** 一棵以 $t$ 为根的最短路树 $T$。

所谓最短路径树，就是满足从树上的每个结点 $x$ 到根节点 $t$ 的简单路径都是 $x$ 到 $t$ 的 **其中** 一条最短路径。

**性质**

设一条从 $s$ 到 $t$ 的路径经过的边集为 $P$，去掉 $P$ 中与 $T$ 的交集得到 $P'$。

$P'$ 有如下性质：

1.  对于一条不在 $T$ 上的边 $e$，其为从 $u$ 到 $v$ 的一条边，边权为 $w$，定义其代价 $\Delta e=dist_v+w-dist_u$，即为选择该边后路径长度的增加量。则路径 $P$ 的长度 $L_P=dist_s+\sum_{e\in P'} \Delta e$。

2.  将 $P$ 和 $P'$ 中的所有边按照从 $s$ 到 $t$ 所经过的顺序依次排列，则对于 $P'$ 中相邻的两条边 $e_1,e_2$，有 $u_{e_2}$ 与 $v_{e_1}$ 相等或为其在 $T$ 上的祖先。因为在 $P$ 中 $e_1,e_2$ 直接相连或中间都为树边。

3.  对于一个确定存在的 $P'$，有且仅有一个 $S$，使得 $S'=P'$。因为由于性质 $2$，$P'$ 中相邻的两条边的起点和终点之间在 $T$ 上只有一条路径。

**问题转化**

性质 $1$ 告诉我们知道集合 $P'$ 后，如何求出 $L_P$ 的值。

性质 $2$ 告诉我们所有 $P'$ 一定满足的条件，所有满足这个条件的边集 $P'$ 都是合法的，也就告诉我们生成 $P'$ 的方法。

性质 $3$ 告诉我们对于每个合法的 $P'$ 有且仅有一个边集 $P$ 与之对应。

那么问题转化为：求 $L_P$ 的值第 $k$ 小的满足性质 $2$ 的集合 $P'$。

**过程**

由于性质 $2$，我们可以记录按照从 $s$ 到 $t$ 的顺序排列的最后一条边和 $L_P$ 的值，来表示一个边集 $P'$。

我们用一个小根堆来维护这样的边集 $P'$。

初始我们将起点为 $1$ 或 $1$ 在 $T$ 上的祖先的所有的边中 $\Delta e$ 最小的一条边加入小根堆。

每次取出堆顶的一个边集 $S$，有两种方法可以生成可能的新边集：

1.  替换 $S$ 中的最后一条边为满足相同条件的 $\Delta e$ 更大的边。

2.  在最后一条边后接上一条边，设 $x$ 为 $S$ 中最后一条边的终点，由性质 $2$ 可得这条边需要满足其起点为 $x$ 或 $x$ 在 $T$ 上的祖先。

将生成的新边集也加入小根堆。重复以上操作 $k-1$ 次后求出的就是从 $s$ 到 $t$ 的第 $k$ 短路。

对于每个结点 $x$，我们将以其为起点的边的 $\Delta e$ 建成一个小根堆。为了方便查找一个结点 $x$ 与 $x$ 在 $T$ 上的祖先在小根堆上的信息，我们将这些信息合并在一个编号为 $x$ 的小根堆上。回顾以上生成新边集的方法，我们发现只要我们把紧接着可能的下一个边集加入小根堆，并保证这种生成方法可以覆盖所有可能的边集即可。记录最后选择的一条边在堆上对应的结点 $t$，有更优的方法生成新的边集：

1.  替换 $S$ 中的最后一条边为 $t$ 在堆上的左右儿子对应的边。

2.  在最后一条边后接上一条新的边，设 $x$ 为 $S$ 中最后一条边的终点，则接上编号为 $x$ 的小根堆的堆顶结点对应的边。

用这种方法，每次生成新的边集只会扩展出最多三个结点，小根堆中的结点总数是 $O(n+k)$。

所以此算法的瓶颈在合并一个结点与其在 $T$ 上的祖先的信息，如果使用朴素的二叉堆，时间复杂度为 $O(nm\log m)$，空间复杂度为 $O(nm)$；如果使用可并堆，每次仍然需要复制堆中的全部结点，时间复杂度同样无法承受。

**可持久化可并堆优化**

使用可持久化可并堆优化合并一个结点与其在 $T$ 上的祖先的信息，  
每次将一个结点与其在 $T$ 上的父亲合并，时间复杂度为 $O((n+m)\log m+k\log k)$，空间复杂度为 $O(m+n\log m+k)$。这样在求出一个结点对应的堆时，无需复制结点且之后其父亲结点对应的堆仍然可以正常访问。

注意的是，如上文所言，最终询问时不需要可并堆的合并操作。  
询问时使用优先队列维护可并堆的根，对于可并堆堆顶的删除，直接将其左右儿子加入优先队列中，  
就只需要 $O(k)$ 而非 $O(k\log m)$ 的空间。

**实现**

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int maxn = 200010;
int n, m, s, t, k, x, y, ww, cnt, fa[maxn];

struct Edge {
  int cur, h[maxn], nxt[maxn], p[maxn], w[maxn];

  void add_edge(int x, int y, int z) {
    cur++;
    nxt[cur] = h[x];
    h[x] = cur;
    p[cur] = y;
    w[cur] = z;
  }
} e1, e2;

int dist[maxn];
bool tf[maxn], vis[maxn], ontree[maxn];

struct node {
  int x, v;

  node* operator=(node a) {
    x = a.x;
    v = a.v;
    return this;
  }

  bool operator<(node a) const { return v > a.v; }
} a;

priority_queue<node> Q;

void dfs(int x) {
  vis[x] = true;
  for (int j = e2.h[x]; j; j = e2.nxt[j])
    if (!vis[e2.p[j]])
      if (dist[e2.p[j]] == dist[x] + e2.w[j])
        fa[e2.p[j]] = x, ontree[j] = true, dfs(e2.p[j]);
}

struct LeftistTree {
  int cnt, rt[maxn], lc[maxn * 20], rc[maxn * 20], dist[maxn * 20];
  node v[maxn * 20];

  LeftistTree() { dist[0] = -1; }

  int newnode(node w) {
    cnt++;
    v[cnt] = w;
    return cnt;
  }

  int merge(int x, int y) {
    if (!x || !y) return x + y;
    if (v[x] > v[y]) swap(x, y);
    int p = ++cnt;
    lc[p] = lc[x];
    v[p] = v[x];
    rc[p] = merge(rc[x], y);
    if (dist[lc[p]] < dist[rc[p]]) swap(lc[p], rc[p]);
    dist[p] = dist[rc[p]] + 1;
    return p;
  }
} st;

void dfs2(int x) {
  vis[x] = true;
  if (fa[x]) st.rt[x] = st.merge(st.rt[x], st.rt[fa[x]]);
  for (int j = e2.h[x]; j; j = e2.nxt[j])
    if (fa[e2.p[j]] == x && !vis[e2.p[j]]) dfs2(e2.p[j]);
}

int main() {
  scanf("%d%d%d%d%d", &n, &m, &s, &t, &k);
  for (int i = 1; i <= m; i++)
    scanf("%d%d%d", &x, &y, &ww), e1.add_edge(x, y, ww), e2.add_edge(y, x, ww);
  Q.push({t, 0});
  while (!Q.empty()) {
    a = Q.top();
    Q.pop();
    if (tf[a.x]) continue;
    tf[a.x] = true;
    dist[a.x] = a.v;
    for (int j = e2.h[a.x]; j; j = e2.nxt[j]) Q.push({e2.p[j], a.v + e2.w[j]});
  }
  if (k == 1) {
    if (tf[s])
      printf("%d\n", dist[s]);
    else
      printf("-1\n");
    return 0;
  }
  dfs(t);
  for (int i = 1; i <= n; i++)
    if (tf[i])
      for (int j = e1.h[i]; j; j = e1.nxt[j])
        if (!ontree[j])
          if (tf[e1.p[j]])
            st.rt[i] = st.merge(
                st.rt[i],
                st.newnode({e1.p[j], dist[e1.p[j]] + e1.w[j] - dist[i]}));
  for (int i = 1; i <= n; i++) vis[i] = false;
  dfs2(t);
  if (st.rt[s]) Q.push({st.rt[s], dist[s] + st.v[st.rt[s]].v});
  while (!Q.empty()) {
    a = Q.top();
    Q.pop();
    cnt++;
    if (cnt == k - 1) {
      printf("%d\n", a.v);
      return 0;
    }
    if (st.lc[a.x])  // 可并堆删除直接把左右儿子加入优先队列中
      Q.push({st.lc[a.x], a.v - st.v[a.x].v + st.v[st.lc[a.x]].v});
    if (st.rc[a.x])
      Q.push({st.rc[a.x], a.v - st.v[a.x].v + st.v[st.rc[a.x]].v});
    x = st.rt[st.v[a.x].x];
    if (x) Q.push({x, a.v + st.v[x].v});
  }
  printf("-1\n");
  return 0;
}
```

## 同余最短路

当出现形如「给定 $n$ 个整数，求这 $n$ 个整数能拼凑出多少的其他整数（$n$ 个整数可以重复取）」，以及「给定 $n$ 个整数，求这 $n$ 个整数不能拼凑出的最小（最大）的整数」，或者「至少要拼几次才能拼出模 $K$ 余 $p$ 的数」的问题时可以使用同余最短路的方法。

同余最短路利用同余来构造一些状态，可以达到优化空间复杂度的目的。

类比差分约束方法，利用同余构造的这些状态可以看作单源最短路中的点。同余最短路的状态转移通常是这样的 $f(i+y) = f(i) + y$，类似单源最短路中 $f(v) = f(u) +edge(u,v)$。

**例题**

**例题一**

题目大意：给定 $x，y，z，h$，对于 $k \in [1,h]$，有多少个 $k$ 能够满足 $ax+by+cz=k$。（$0\leq a,b,c$，$1\le x,y,z\le 10^5$，$h\le 2^{63}-1$）

不妨假设 $x < y < z$。

令 $d_i$ 为只通过 **操作 2** 和 **操作 3**，需满足 $p\bmod x = i$ 能够达到的最低楼层 $p$，即 **操作 2** 和 **操作 3** 操作后能得到的模 $x$ 下与 $i$ 同余的最小数，用来计算该同余类满足条件的数个数。

可以得到两个状态：

-   $i \xrightarrow{y} (i+y) \bmod x$

-   $i \xrightarrow{z} (i+z) \bmod x$

注意通常选取一组 $a_i$ 中最小的那个数对它取模，也就是此处的 $x$，这样可以尽量减小空间复杂度（剩余系最小）。

那么实际上相当于执行了最短路中的建边操作：

`add(i, (i+y) % x, y)`

`add(i, (i+z) % x, z)`

接下来只需要求出 $d_0, d_1, d_2, \dots, d_{x-1}$，只需要跑一次最短路就可求出相应的 $d_i$。

与差分约束问题相同，当存在一组解 $\{a_1,a_2,\cdots,a_n\}$ 时，$\{a_1+d,a_2+d,\cdots,a_n+d\}$ 同样为一组解，因此在该题让 $i=1$ 作为源点，此时源点处的 $dis_{1}=1$ 在已知范围内最小，因此得到的也是一组最小的解。

答案即为：

$$
\sum_{i=0}^{x-1}\left(\frac{h-d_i}{x} + 1\right)
$$

加 1 是由于 $d_i$ 所在楼层也算一次。

代码实现上注意到 $h$ 的范围是 $h \leq 2^{63}-1$，所以在求解最短路之前 $d_i$ 的初始值应至少设为 $2^{63}$，这超过了 C++ 中 `long long` 的最大值。所以可以使用 `unsigned long long` 或者先把 $h \gets h - 1$，然后把最低楼层设为 $0$ 层，其他代码无异。

```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
const int maxn = 100010;
const int INF = 0x3f3f3f3f;
const long long linf = (1ull << 63) - 1;

ll h, x, y, z;
ll head[maxn << 1], tot;
ll dis[maxn], vis[maxn];
queue<int> q;

struct edge {
  ll to, next, w;
} e[maxn << 1];

void add(ll u, ll v, ll w) {
  e[++tot] = edge{v, head[u], w};
  head[u] = tot;
}

void spfa() {  // spfa算法，可看最短路部分
  dis[0] = 0; vis[0] = 1;
  q.push(0);
  while (!q.empty()) {
    int u = q.front();
    q.pop();
    vis[u] = 0;
    for (int i = head[u]; i; i = e[i].next) {
      int v = e[i].to, w = e[i].w;
      if (dis[v] > dis[u] + w) {
        dis[v] = dis[u] + w;
        if (!vis[v]) {
          q.push(v);
          vis[v] = 1;
        }
      }
    }
  }
}

int main() {
  scanf("%lld", &h);
  scanf("%lld %lld %lld", &x, &y, &z);
  if (x == 1 || y == 1 || z == 1) {
    printf("%lld\n", h);
    return 0;
  }
  --h;
  for (int i = 0; i < x; i++) {
    add(i, (i + z) % x, z);
    add(i, (i + y) % x, y);
    dis[i] = linf;
  }
  spfa();
  ll ans = 0;
  for (int i = 0; i < x; i++) if (h >= dis[i]) ans += (h - dis[i]) / x + 1;
  printf("%lld\n", ans);
  return 0;
}
```

**例题二**

题目大意：给定 $n$，求 $n$ 的倍数中，数位和最小的那一个的数位和。（$1\le n\le 10^5$）

本题可以使用循环卷积优化完全背包在 $O(n\log^2 n)$ 的时间内解决，但我们希望得到线性的算法。

观察到任意一个正整数都可以从 $1$ 开始，按照某种顺序执行乘 $10$、加 $1$ 的操作，最终得到，而其中加 $1$ 操作的次数就是这个数的数位和。这提示我们使用最短路。

对于所有 $0\le k\le n-1$，从 $k$ 向 $10k$ 连边权为 $0$ 的边；从 $k$ 向 $k+1$ 连边权为 $1$ 的边。（点的编号均在模 $n$ 意义下）

每个 $n$ 的倍数在这个图中都对应了 $1$ 号点到 $0$ 号点的一条路径，求出 $1$ 到 $0$ 的最短路即可。某些路径不合法（如连续走了 $10$ 条边权为 $1$ 的边），但这些路径产生的答案一定不优，不影响答案。

时间复杂度 $O(n)$。


## 弦图

弦图是一种特殊的图，很多在一般图上的 NP-Hard 问题在弦图上都有优秀的线性时间复杂度算法。

**一些定义与性质**

**子图**：点集和边集均为原图点集和边集子集的图。

**导出子图（诱导子图）**：点集为原图点集子集，边集为所有满足 **两个端点均在选定点集中** 的图。

**团**：完全子图。

**极大团**：不是其他团子图的图。

**最大团**：点数最大的团。

**团数**：最大团的点数，记为 $\omega(G)$。

**最小染色**：用最少的颜色给点染色使得所有边连接的两点颜色不同。

**色数**：最小染色的颜色数，记为 $\chi(G)$。

**最大独立集**：最大的点集使得点集中任意两点都没有边直接相连。该集合的大小记为 $\alpha(G)$。

**最小团覆盖**：用最少的团覆盖所有的点。使用团的数量记为 $\kappa(G)$。

**弦**：连接环中不相邻两点的边。

**弦图**：任意长度大于 $3$ 的环都有一个弦的图称为弦图。

**Lemma 1**：团数 $\omega(G)\le \chi(G)$ 色数

证明：考虑单独对最大团的导出子图进行染色，至少需要 $\omega(G)$ 种颜色。

**Lemma 2**：最大独立集数 $\alpha(G)\le \kappa(G)$ 最小团覆盖数

证明：每个团中至多选择一个点。

**Lemma 3**：弦图的任意导出子图一定是弦图。

证明：如果弦图有导出子图不是弦图，说明在这个导出子图上存在大于 $3$ 的无弦环，则无论原图如何（怎么加边）都不会使得原图是弦图，矛盾。

**Lemma 4**：弦图的任意导出子图一定不可能是一个点数大于 $3$ 的环。

证明：一个点数大于 $3$ 的环不是弦图，用以上定理即可。

### 判定

**问题描述**

给定一个无向图，判断其是否为弦图。

**点割集**

对于图 $G$ 上的两点 $u,v$，定义这两点间的 **点割集** 为满足删除这一集合后，$u,v$ 两点之间不连通。如果关于 $u,v$ 两点间的一个点割集的任意子集都不是点割集，则称这个点割集为 **极小点割集**。

**Lemma 5**：图关于 $u,v$ 的极小点割集将原图分成了若干个连通块，设包含 $u$ 的连通块为 $V_1$，包含 $v$ 的连通块为 $V_2$，则对于极小点割集上的任意一点 $a$，$N(a)$ 一定包含 $V_1$ 和 $V_2$ 中的点。

证明：若 $N(a)$ 只包含 $V_1$ 或 $V_2$ 中的至多一个连通块中的点，从点割集中删去 $a$ 点，仍不连通，则原点割集不是最小点割集。

**Lemma 6**：弦图上任意两点间的极小点割集的导出子图一定为一个团。

证明：极小点割集大小 $\le 1$ 时，导出子图一定为一个团。

否则，设极小点割集上有两点为 $x,y$，由 **Lemma 5** 得，$N(x)$ 中有 $V_1,V_2$ 中的点，设为 $x_1,x_2$，同样的，设 $y_1,y_2$，注意，可能有 $x_1=y_1,x_2=y_2$。

由于 $V_1,V_2$ 均为连通块，则在 $x_1,y_1$ 和 $x_2,y_2$ 两个点对之间存在最短路径。设 $x,y$ 在 $V_1,V_2$ 内部的最短路为 $x-x_1\sim y_1-y,x-x_2\sim y_2-y$，则图上存在一个环 $x-x_1\sim y_1-y-y_2\sim x_2-x$，该环的大小一定 $\ge 4$，根据弦图的定义，此时该环上一定存在一条弦。

若这条弦连接了 $V_1,V_2$ 两个连通块，则点集不是点割集。若这条弦连接了单个连通块内部的两个点或一个连通块内部的一个点和一个点割集上的点，都不满足最短路的性质。所以这条弦只能连接 $x,y$ 两点。

由此，可证弦图中每个极小点割集中的两点都有边直接相连，故性质得证。

**单纯点**

设 $N(x)$ 表示与点 $x$ 相邻的点集。若点集 $\{x\}+N(x)$ 的导出子图为一个团，则称点 $x$ 为单纯点。

**Lemma 7**：任何一个弦图都至少有一个单纯点，不是完全图的弦图至少有两个不相邻的单纯点。

证明：数学归纳法。单独考虑每一连通块。

归纳基底：当图与完全图同构时，图上任意一点都是单纯点。当图的点数 $\le 3$ 时，引理成立。

若图上的点数 $\ge 4$ 且图不为完全图，可知必然存在 $u,v$ 使得 $(u,v)\notin E$。设 $I$ 是图关于 $u,v$ 的极小点割集。设 $A,B$ 分别是删去 $I$ 后的导出子图上 $u,v$ 所在的连通块。由于问题的对称性，我们只考虑 $A$ 一侧的情况，设 $L=A+I$。若 $L$ 为完全图，则 $u$ 为单纯点；若不是，因为 $L$ 是原图的导出子图，一定也是弦图，所以有两个不相邻的单纯点，因为 $I$ 是一个团，其上两点都相邻，所以 $A$ 中一定有一个单纯点。该单纯点扩展到全图也为单纯点。

由于每次将整个图分成若干个连通块证明，大小一定减小，且都满足性质，故归纳成立。

**完美消除序列**

令 $n=|V|$，完美消除序列 $v_1,v_2,\ldots ,v_n$ 为 $1,2,\ldots ,n$ 的一个排列，满足 $v_i$ 在 $\{v_i,v_{i+1},\ldots ,v_n\}$ 的导出子图中为单纯点。

**Lemma 8**：一个无向图是弦图当且仅当其有一个完全消除序列。

充分性：点数为 $1$ 的弦图有完全消除序列。由 **Lemma 3** 和 **Lemma 7**，点数为 $n$ 的弦图的完美消除序列可以由点数为 $n-1$ 的弦图的完美消除序列加上一个单纯点得到。

必要性：假设有无向图存在结点数 $>3$ 的环且拥有完美消除序列，设在完美消除序列中出现的第一个环上的点为 $v$，设 $v$ 在环上与 $v_1,v_2$ 相连，则有完美消除序列的性质即单纯点的定义可得 $v_1,v_2$ 直接有边相连，矛盾。

**朴素算法**

每次找到一个 **单纯点**  $v$，加入到完美消除序列中。

将点 $v$ 与其相邻的边从图上删除。

重复以上过程，若所有点都被删除，则原图是弦图且求得了一个完美消除序列；若图上不存在单纯点，则原图不是弦图。

时间复杂度 $O(n^4)$。

**MCS 算法**

**最大势算法**（Maximum Cardinality Search）是一种可以在 $O(n+m)$ 的时间复杂度内求出无向图的完美消除序列的方法。

逆序给结点编号，即按从 $n$ 到 $1$ 的顺序给点标号。

设 $label_x$ 表示第 $x$ 个点与多少个已经标号的点相邻，每次选择 $label$ 值最大的未标号结点进行标号。

用链表维护对于每个 $i$，满足 $label_x=i$ 的 $x$。

由于每条边对 $\sum_{i=1}^n label_i$ 的贡献最多是 $2$，时间复杂度 $O(n+m)$。

**正确性证明**：

设 $\alpha(x)$ 为 $x$ 在这个序列中的位置。
我们需要证明对于任何一个弦图，算法求出的序列一定是一个完美消除序列，即在序列中位于某个点后面且与这个点相连的所有点两两相连。

**Lemma 9**：考虑三个点 $u,v,w$ 满足 $\alpha(u)<\alpha(v)<\alpha(w)$，如果 $uw$ 相连，$vw$ 不相连，则 $w$ 只给 $u$ 的 $label$ 贡献，不给 $v$ 贡献。为了让 $v$ 比 $u$ 先加入序列，需要一个 $x$ 满足 $\alpha(v)<\alpha(x)$ 且 $vx$ 相连，$ux$ 不相连，即 $x$ 只给 $v$ 贡献而不给 $u$ 贡献。

**Lemma 10**：任意一个弦图一定不存在一个序列 $v_0,v_1,\dots,v_k(k\ge 2)$ 满足下列性质：

1.  $v_iv_j$ 相连当且仅当 $|i-j|=1$。
2.  $\alpha(v_0)>\alpha(v_i)(i\in[1,k])$。
3.  存在 $i\in[1,k-1]$，满足 $\alpha(v_i)<\alpha(v_{i+1})<\dots<\alpha(v_k)$ 且 $\alpha(v_i)<\alpha(v_{i-1})<\dots<\alpha(v_1)<\alpha(v_k)<\alpha(v_0)$。

证明：

由于 $\alpha(v_1)<\alpha(v_k)<\alpha(v_0)$，且 $v_1v_0$ 相连，$v_kv_0$ 不相连，所以由性质一，存在 $x$ 满足 $\alpha(v_k)<\alpha(x)$ 且 $v_kx$ 相连，$v_1x$ 不相连。

考虑最小的 $j\in(1,k]$ 满足 $v_jx$ 相连，我们可以推出 $v_0x$ 不相连，否则 $v_0v_1\cdots v_jx$ 构成了一个长度 $\ge 4$ 且无弦的环。

如果 $x<v_0$，则 $v_0,v_1,\dots,v_j,x$ 也是一个满足性质的序列；如果 $v_0<x$ 则 $x,v_j,\dots,v_1,v_0$ 也是一个满足性质的序列。

在上面的推导中，我们扩大了 $\min(v_0,v_k)$，于是一直推下去，一定会产生矛盾。

**Theorem 1**：对于任何一个弦图，最大势算法求出的序列一定是一个完美消除序列。

证明：考虑任意三个点 $u,v,w$ 满足 $\alpha(u)<\alpha(v)<\alpha(w)$，我们需要证明若 $uv$ 相连，$uw$ 相连，则 $vw$ 一定相连。

考虑反证法，假设不相连，那么 $w,u,v$ 就是一个满足 **Lemma 10** 中性质的序列，我们证明了这样序列不存在，所以矛盾，$vw$ 相连。

参考代码：

```cpp
while (cur) {
  p[cur] = h[nww];
  rnk[p[cur]] = cur;
  h[nww] = nxt[h[nww]];
  lst[h[nww]] = 0;
  lst[p[cur]] = nxt[p[cur]] = 0;
  tf[p[cur]] = true;
  for (vector<int>::iterator it = G[p[cur]].begin(); it != G[p[cur]].end();
       it++)
    if (!tf[*it]) {
      if (h[deg[*it]] == *it) h[deg[*it]] = nxt[*it];
      nxt[lst[*it]] = nxt[*it];
      lst[nxt[*it]] = lst[*it];
      lst[*it] = nxt[*it] = 0;
      deg[*it]++;
      nxt[*it] = h[deg[*it]];
      lst[h[deg[*it]]] = *it;
      h[deg[*it]] = *it;
    }
  cur--;
  if (h[nww + 1]) nww++;
  while (nww && !h[nww]) nww--;
}
```

如果此时原图是弦图，此时求出的就是完美消除序列；但是由于原图可能不是弦图，此时求出的一定不是完美消除序列，所以问题转化为 **判断求出的序列是否是原图的完美消除序列**。

**判断一个序列是否是完美消除序列**

**朴素算法**

根据定义，依次判断完美消除序列 $v$ 上 $\{v_i,v_{i+1},\ldots ,v_n\}$ 中与 $v_i$ 相邻的点是否构成了一个团。时间复杂度 $O(nm)$。

**优化后的算法**

根据完美消除序列的定义，设 $v_i$ 在 ${v_i,v_{i+1},\ldots , v_n}$ 中相邻的点从小到大为 $\{v_{c_1},v_{c_2},\ldots ,v_{c_k} \}$，则只需判断 $v_{c_1}$ 与其他点是否直接连通即可。时间复杂度 $O(n+m)$。

```cpp
jud = true;
for (int i = 1; i <= n; i++) {
  cur = 0;
  for (vector<int>::iterator it = G[p[i]].begin(); it != G[p[i]].end(); it++)
    if (rnk[p[i]] < rnk[*it]) {
      s[++cur] = *it;
      if (rnk[s[cur]] < rnk[s[1]]) swap(s[1], s[cur]);
    }
  for (int j = 2; j <= cur; j++)
    if (!st[s[1]].count(s[j])) {
      jud = false;
      break;
    }
}
if (!jud)
  printf("Imperfect\n");
else
  printf("Perfect\n");
```

至此，**弦图判定问题** 可以在 $O(n+m)$ 的时间复杂度内解决。

### 极大团

令 $N(x)$ 为满足与 $x$ 直接有边相连且在完美消除序列上的 $x$ 之后的序列。则弦图的极大团一定为 $\{x\}+N(x)$。

证明：考虑弦图的一个极大团 $V$，其中的点在完美消除序列中出现的第一个点 $x$，一定有 $V\subseteq \{x\}+N(x)$，又因为 $V$ 是极大团，所以 $V=\{x\}+N(x)$。

弦图最多有 $n$ 个极大团。求出弦图的每个极大团，可以判断每个 $\{x\}+N(x)$ 是否为极大团。

设 $A=\{x\}+N(x),B=\{y\}+N(y)$，若 $A\subsetneqq B$，则 $A$ 不是极大团。此时在完美消除序列上显然有 $y$ 在 $x$ 前。

设 $nxt_x$ 表示 $N(x)$ 中在完美消除序列上最靠前的点，$y*$ 表示所有满足 $A\subseteq B$ 的 $y$ 中的最靠后的点。此时必然有 $nxt_{y*}=x$，否则 $y*$ 不是最靠后的，令 $y*=nxt_{y*}$ 仍然满足条件。

$A\subsetneqq B$ 当且仅当 $|A|+1\le |B|$。

问题转化为判断是否存在 $y$，满足 $nxt_y=x$ 且 $|N(x)|+1\le |N(y)|$。时间复杂度 $O(n+m)$。

```cpp
for (int i = 1; i <= n; i++) {
  cur = 0;
  for (vector<int>::iterator it = G[p[i]].begin(); it != G[p[i]].end(); it++)
    if (rnk[p[i]] < rnk[*it]) {
      s[++cur] = *it;
      if (rnk[s[cur]] < rnk[s[1]]) swap(s[1], s[cur]);
    }
  fst[p[i]] = s[1];
  N[p[i]] = cur;
}
for (int i = 1; i <= n; i++) {
  if (!vis[p[i]]) ans++;
  if (N[p[i]] >= N[fst[p[i]]] + 1) vis[fst[p[i]]] = true;
}
```

### 色数/团数

一种构造方法：按完美消除序列从后往前依次给每个点染色，给每个点染上可以染的最小颜色。时间复杂度 $O(m+n)$。

正确性证明：设以上方法使用了 $t$ 种颜色，则 $t\ge \chi(G)$。由于团上每个点都是不同的颜色，所以 $t=\omega(G)$，由 **Lemma 1**，$t=\omega(G)\le \chi(G)$。综上，可得 $t=\chi(G)=\omega(G)$。

无需染色方案，只需求出弦图的色数/团数时，可以取 $|\{x\}+N(x)|$ 的最大值得到。

```cpp
for (int i = 1; i <= n; i++) ans = max(ans, deg[i] + 1);
```

### 最大独立集/最小团覆盖

最大独立集：完美消除序列从前往后，选择所有没有与已经选择的点有直接连边的点。

最小团覆盖：设最大独立集为 $\{v_1,v_2,\ldots ,v_t\}$，则团的集合 $\{\{v_1+N(v_1)\},\{v_2+N(v_2)\},\ldots ,\{v_t+N(v_t)\} \}$ 为图的最小团覆盖。时间复杂度均为 $O(n+m)$。

正确性证明：设以上方案独立集数和团覆盖数为 $t$，由定义得 $t\le \alpha(G),t\ge \kappa(G)$，由 **Lemma 2** 得，$\alpha(G)\le \kappa(G)$，所以 $t=\alpha(G)=\kappa(G)$。

```cpp
for (int i = 1; i <= n; i++)
  if (!vis[p[i]]) {
    ans++;
    for (vector<int>::iterator it = G[p[i]].begin(); it != G[p[i]].end(); it++)
      vis[*it] = true;
  }
```

## A \*

**定义**

A \* 搜索算法（英文：A\*search algorithm，A \* 读作 A-star），简称 A \* 算法，是一种在图形平面上，对于有多个节点的路径求出最低通过成本的算法。它属于图遍历（英文：Graph traversal）和最佳优先搜索算法（英文：Best-first search），亦是BFS的改进。

**过程**

定义起点 $s$，终点 $t$，从起点（初始状态）开始的距离函数 $g(x)$，到终点（最终状态）的距离函数 $h(x)$，$h^{\ast}(x)$[^note1]，以及每个点的估价函数 $f(x)=g(x)+h(x)$。

A \* 算法每次从优先队列中取出一个 $f$ 最小的元素，然后更新相邻的状态。

如果 $h\leq h*$，则 A \* 算法能找到最优解。

上述条件下，如果 $h$ 满足三角形不等式，则 A \* 算法不会将重复结点加入队列。

当 $h=0$ 时，A \* 算法变为Dijkstra；当 $h=0$ 并且边权为 $1$ 时变为BFS。

**例题:八数码**

题目大意：在 $3\times 3$ 的棋盘上，摆有八个棋子，每个棋子上标有 $1$ 至 $8$ 的某一数字。棋盘中留有一个空格，空格用 $0$ 来表示。空格周围的棋子可以移到空格中，这样原来的位置就会变成空格。给出一种初始布局和目标布局（为了使题目简单，设目标状态如下），找到一种从初始布局到目标布局最少步骤的移动方法。
    
```plain
    123
    804
    765
```

$h$ 函数可以定义为，不在应该在的位置的数字个数。
    
容易发现 $h$ 满足以上两个性质，此题可以使用 A \* 算法求解。

参考代码
```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
#include <set>
using namespace std;
const int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};
int fx, fy;
char ch;

struct matrix {
  int a[5][5];

  bool operator<(matrix x) const {
    for (int i = 1; i <= 3; i++)
      for (int j = 1; j <= 3; j++)
        if (a[i][j] != x.a[i][j]) return a[i][j] < x.a[i][j];
    return false;
  }
} f, st;

int h(matrix a) {
  int ret = 0;
  for (int i = 1; i <= 3; i++)
    for (int j = 1; j <= 3; j++)
      if (a.a[i][j] != st.a[i][j]) ret++;
  return ret;
}

struct node {
  matrix a;
  int t;

  bool operator<(node x) const { return t + h(a) > x.t + h(x.a); }
} x;

priority_queue<node> q;  // 搜索队列
set<matrix> s;           // 防止搜索队列重复

int main() {
  st.a[1][1] = 1;  // 定义标准表
  st.a[1][2] = 2;
  st.a[1][3] = 3;
  st.a[2][1] = 8;
  st.a[2][2] = 0;
  st.a[2][3] = 4;
  st.a[3][1] = 7;
  st.a[3][2] = 6;
  st.a[3][3] = 5;
  for (int i = 1; i <= 3; i++)  // 输入
    for (int j = 1; j <= 3; j++) {
      scanf(" %c", &ch);
      f.a[i][j] = ch - '0';
    }
  q.push({f, 0});
  while (!q.empty()) {
    x = q.top();
    q.pop();
    if (!h(x.a)) {  // 判断是否与标准矩阵一致
      printf("%d\n", x.t);
      return 0;
    }
    for (int i = 1; i <= 3; i++)
      for (int j = 1; j <= 3; j++)
        if (!x.a.a[i][j]) fx = i, fy = j;  // 查找空格子（0号点）的位置
    for (int i = 0; i < 4; i++) {  // 对四种移动方式分别进行搜索
      int xx = fx + dx[i], yy = fy + dy[i];
      if (1 <= xx && xx <= 3 && 1 <= yy && yy <= 3) {
        swap(x.a.a[fx][fy], x.a.a[xx][yy]);
        if (!s.count(x.a))
          s.insert(x.a),
              q.push({x.a, x.t + 1});  // 这样移动后，将新的情况放入搜索队列中
        swap(x.a.a[fx][fy], x.a.a[xx][yy]);  // 如果不这样移动的情况
      }
    }
  }
  return 0;
}
```

