# 数据结构

[TOC]

## 并查集

合并两个集合，迅速判断两个元素是否在同一集合中

```cpp
int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

// 合并时
p[find(a)] = find(b);
```

## 可撤销并查集

```cpp
struct DSU
{
    int n;
    vector<int> p, high;
    struct node
    {
        int x, y, hy;
    };
    stack<node> stk;
    DSU(int n) : n(n), p(n + 1), high(n + 1, 0)
    {
        for (int i = 1; i <= n; i ++ ) p[i] = i;
    }
    // 查找x的根
    int find(int x)
    {
        while (x != p[x]) x = p[x];
        return p[x];
    }
    // 按秩合并x和y
    void merge(int x, int y)
    {
        x = find(x), y = find(y);
        if (high[x] > high[y]) swap(x, y);
        stk.push({x, y, high[y]});
        p[x] = y;
        high[y] += (high[x] == high[y]);
    }
    // 撤销合并
    void cancel(int nw)
    {
        while (stk.size() > nw)
        {
            auto t = stk.top();
            stk.pop();
            p[t.x] = t.x;
            high[t.y] = t.hy;
        }
    }
};
```

## 树状数组

单点修改，区间查询

时间复杂度：$O(logn)$

```cpp
struct BIT
{
	const int n;
	vector<int> tree;
	BIT(int n) : n(n), tree(n + 1) {};
	// 询问前x个数的和
	int Query(int x)
	{
		int res = 0;
		for (int i = x; i > 0; i -= (i & -i)) res += tree[i];
		return res;
	}
	// 第l个位置+z
	void Modify(int l, int z)
	{
		if (l <= 0) return;
		for (int i = l; i <= n; i += (i & -i)) tree[i] += z;
	}
	// 区间求和
	int rangeQuery(int l, int r)
	{
		return Query(min(n, r)) - Query(max(0ll, l - 1));
	}
};
```

## ST 表

不需要区间修改的可重复贡献问题

时间复杂度：预处理$O(nlogn)$ 查询$O(1)$

```cpp
struct ST
{
	// st[i][j]表示区间[i,i+2^j-1]的最大值
	// 定义后init() 即可直接使用
	int n;
	vector<vector<int>> st;
    vector<int> lg;
	ST(int n) : n(n), st(n + 1, vector<int>(32)), lg(n + 1) {};
	// 预处理区间最大值 可根据题目修改 传入原数组
	void init(vector<int> &a)
	{
		for (int i = 1; i <= n; i ++ ) st[i][0] = a[i];
		lg[0] = -1;
		for (int i = 1; i <= n; i++)
		{
			lg[i] = lg[i >> 1] + 1;
		}
		for (int j = 1; j <= lg[n]; j++)
		{
			for (int i = 1; i <= n - (1 << (j - 1)); i++)
			{
				st[i][j] = max(st[i][j - 1], st[i + (1ll << (j - 1))][j - 1]);
			}
		}
	}
	// 查询区间最大值 可根据题目修改
	int query(int l, int r)
	{
		int len = lg[r - l + 1];
		return max(st[l][len], st[r - (1ll << len) + 1][len]);
	}
};
```

## 线段树

### 普通线段树（单点修改、区间修改、区间查询）

#### 递归版

```cpp
struct Segment_Tree
{
	// 定义后读入数组a build(1, 1, n)后即可直接使用
	int n; // 数组长度
	vector<int> a; // 原数组
	struct node
	{
		int l, r; // 左右边界
		// 需要维护的其他信息
		int sum; // 区间和
		int tag; // 懒标记
	};
	vector<node> tr;
	Segment_Tree(int n) : n(n), a(n + 1), tr((n + 1) * 4) {};

	void pushup(node &u, node &lt, node &rt)
	{
		u.l = lt.l, u.r = rt.r;
		// 维护其余信息
		u.sum = lt.sum + rt.sum;
	};
	void pushup(int u)
	{
		pushup(tr[u], tr[u << 1], tr[u << 1 | 1]);
	}
	void pushdown(int u)
	{
		auto &root = tr[u], &left = tr[u << 1], &right = tr[u << 1 | 1];
		if (root.tag)
		{
    	    left.tag += root.tag, left.sum += (long long)(left.r - left.l + 1) * root.tag;
    	    right.tag += root.tag, right.sum += (long long)(right.r - right.l + 1) * root.tag;
    	    root.tag = 0;
    	}
	}
	void build(int u, int l, int r)
	{
		tr[u] = {l, r};
		if (l == r)
		{
			tr[u].sum = a[l];
			return;
		}
		int mid = l + r >> 1;
		build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
		pushup(u); // 根据具体情况有时可以舍去
	}
	// 单点修改：a[pos] += x
	void modify(int u, int pos, int x)
	{
		if (tr[u].l == pos && tr[u].r == pos)
		{
			tr[u].sum += x;
			return;
		}
		int mid = tr[u].l + tr[u].r >> 1;
		if (pos <= mid) modify(u << 1, pos, x);
		else modify(u << 1 | 1, pos, x);
		pushup(u);
	}
	// 区间修改：a[l...r] += x
	void modify(int u, int l, int r, int x)
	{
    	if (tr[u].l >= l && tr[u].r <= r)
    	{
    	    tr[u].sum += (long long)(tr[u].r - tr[u].l + 1) * x;
    	    tr[u].tag += x;
			return;
    	}
    	pushdown(u);
    	int mid = tr[u].l + tr[u].r >> 1;
    	if (l <= mid) modify(u << 1, l, r, x);
    	if (r > mid) modify(u << 1 | 1, l, r, x);
    	pushup(u);
	}
	// 区间查询 返回对应区间的node结点
	node query(int u, int l, int r)
	{
		if (tr[u].l >= l && tr[u].r <= r) return tr[u];
		pushdown(u);
		int mid = tr[u].l + tr[u].r >> 1;
		if (r <= mid) return query(u << 1, l, r);
		else if (l > mid) return query(u << 1 | 1, l, r);
		else
		{
			node res;
			auto lt = query(u << 1, l, mid);
			auto rt = query(u << 1 | 1, mid + 1, r);
			pushup(res, lt, rt);
			return res;
		}
	}
};
```

#### zkw线段树版

```cpp
struct Segment_Tree
{
    struct node
    {
        int val, tag;
        node() : val(0), tag(0) {};
    };
    vector<node> tr;
    int n, N;
    vector<int> a;
    Segment_Tree(int n) : n(n), N(1), tr((n + 1) << 2), a(n +1) {};
    void build()
    {
        for (; N <= n + 1; N <<= 1) ;
        for (int i = N + 1; i <= N + n; i ++ ) tr[i].val = a[i- N];
        for (int i = N - 1; i >= 1; i -- ) tr[i].val = tr[i <<1].val + tr[i << 1 | 1].val;
    }
    // 单点修改
    void modify(int x, int k)
    {
        for (x += N; x; x >>= 1) tr[x].val += k;
    }
    // 区间修改
    void modify(int s, int t, int k)
    {
        int lNum = 0, rNum = 0, nNum = 1;
        for (s = N + s - 1, t = N + t + 1; s ^ t ^ 1; s >>= 1,t >>= 1, nNum <<= 1)
        {
            tr[s].val += k * lNum; tr[t].val += k * rNum;
            if (~s & 1)
            {
                tr[s ^ 1].tag += k; tr[s ^ 1].val += k * nNum;
                lNum += nNum;
            }
            if (t & 1)
            {
                tr[t ^ 1].tag += k; tr[t ^ 1].val += k * nNum;
                rNum += nNum;
            }
        }
        for (; s; s >>= 1, t >>= 1)
        {
            tr[s].val += k * lNum; tr[t].val += k * rNum;
        }
    }
    // 区间查询
    int query(int s, int t)
    {
        int lNum = 0, rNum = 0, nNum = 1;
        int ans = 0;
        for (s = N + s - 1, t = N + t + 1; s ^ t ^ 1; s >>= 1,t >>= 1, nNum <<= 1)
        {
            if (tr[s].tag) ans += tr[s].tag * lNum;
            if (tr[t].tag) ans += tr[t].tag * rNum;
            if (~s & 1)
            {
                ans += tr[s ^ 1].val;
                lNum += nNum;
            }
            if (t & 1)
            {
                ans += tr[t ^ 1].val;
                rNum += nNum;
            }
        }
        for (; s; s >>= 1, t >>= 1)
        {
            ans += tr[s].tag * lNum;
            ans += tr[t].tag * rNum;
        }
        return ans;
    }
};
```

### 吉司机线段树（区间最值操作、查询区间历史最值）

```cpp
struct Segment_Tree
{
	// 定义后读入数组a build(1, 1, n)后即可直接使用
	int n; // 数组长度
	vector<int> a; // 原数组
	struct node
	{
		int l, r; // 左右边界
		int sum; // 区间和
		int maxa, maxb; // 【当前】区间最大值 和 【历史】区间最大值
    	int cnt; // 当前区间最大值的个数
    	int se; // 当前区间次大值
		// 分别表示当前区间最大值的懒标记 当前区间非最大值的懒标记 add1的最大值 add2的最大值
    	int add1, add2, add3, add4;
	};
	vector<node> tr;
	Segment_Tree(int n) : n(n), a(n + 1), tr((n + 1) * 4) {};

	void pushup(node& u, node& lt, node& rt)
	{
	    u.sum = lt.sum + rt.sum;
	    u.maxa = max(lt.maxa, rt.maxa);
	    u.maxb = max(lt.maxb, rt.maxb);
	    if (lt.maxa == rt.maxa) // 左右节点最大值一样大
	    {
	        u.se = max(lt.se, rt.se);
	        u.cnt = lt.cnt + rt.cnt;
	    }
	    else if (lt.maxa > rt.maxa) // 左结点最大值比右结点大
	    {
	        u.se = max(lt.se, rt.maxa);
	        u.cnt = lt.cnt;
	    }
	    else // 右结点最大值比左结点大
	    {
	        u.se = max(lt.maxa, rt.se);
	        u.cnt = rt.cnt;
	    }
	}
	void pushup(int u)
	{
	    pushup(tr[u], tr[u << 1], tr[u << 1 | 1]);
	}
	void change(int u, int add1, int add2, int add3, int add4)
	{
	    tr[u].sum += 1ll * add1 * tr[u].cnt + 1ll * add2 * (tr[u].r - tr[u].l + 1 - tr[u].cnt);
	    tr[u].maxb = max(tr[u].maxb, tr[u].maxa + add3);
	    tr[u].maxa += add1;
	    if (tr[u].maxb != -INF) tr[u].se += add2;
	    tr[u].add3 = max(tr[u].add3, tr[u].add1 + add3);
	    tr[u].add4 = max(tr[u].add4, tr[u].add2 + add4);
	    tr[u].add1 += add1, tr[u].add2 += add2;
	}
	void pushdown(int u)
	{
	    int maxx = max(tr[u << 1].maxa, tr[u << 1 | 1].maxa);
	    // 修改左结点
	    if (tr[u << 1].maxa == maxx) change(u << 1, tr[u].add1, tr[u].add2, tr[u].add3, tr[u].add4);
	    else change(u << 1, tr[u].add2, tr[u].add2, tr[u].add4, tr[u].add4);
	    // 修改右结点
	    if (tr[u << 1 | 1].maxa == maxx) change(u << 1 | 1, tr[u].add1, tr[u].add2, tr[u].add3, tr[u].add4);
	    else change(u << 1 | 1, tr[u].add2, tr[u].add2, tr[u].add4, tr[u].add4);
	    // 清空懒标记
	    tr[u].add1 = tr[u].add2 = tr[u].add3 = tr[u].add4 = 0;
	}
	void build(int u, int l, int r)
	{
	    tr[u] = {l, r};
	    if (l == r)
	    {
	        tr[u].sum = tr[u].maxa = tr[u].maxb = a[l];
	        tr[u].cnt = 1, tr[u].se = -INF;
	        return;
	    }
	    int mid = l + r >> 1;
	    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
	    pushup(u);
	}
	// a[l...r] += x
	void update_add(int u, int l, int r, int x)
	{
	    if (tr[u].l >= l && tr[u].r <= r)
	    {
	        tr[u].sum += 1ll * x * (tr[u].r - tr[u].l + 1);
	        tr[u].maxa += x;
	        tr[u].maxb = max(tr[u].maxb, tr[u].maxa);
	        if (tr[u].se != -INF) tr[u].se += x;
	        tr[u].add1 += x, tr[u].add2 += x;
	        tr[u].add3 = max(tr[u].add3, tr[u].add1);
	        tr[u].add4 = max(tr[u].add4, tr[u].add2);
	    }
	    else
	    {
	        pushdown(u);
	        int mid = tr[u].l + tr[u].r >> 1;
	        if (l <= mid) update_add(u << 1, l, r, x);
	        if (r > mid) update_add(u << 1 | 1, l, r, x);
	        pushup(u);
	    }
	}
	// a[l...r] = min(x, a[i])
	void update_min(int u, int l, int r, int x)
	{
	    if (x >= tr[u].maxa) return;
	    if (tr[u].l >= l && tr[u].r <= r && tr[u].se < x)
	    {
	        int k = tr[u].maxa - x;
	        tr[u].sum -= 1ll * tr[u].cnt * k;
	        tr[u].maxa = x, tr[u].add1 -= k;
	    }
	    else
	    {
	        pushdown(u);
	        int mid = tr[u].l + tr[u].r >> 1;
	        if (l <= mid) update_min(u << 1, l, r, x);
	        if (r > mid) update_min(u << 1 | 1, l, r, x);
	        pushup(u);
	    }
	}
	// 区间查询 返回对应区间结点
	node query(int u, int l, int r)
	{
	    if (tr[u].l >= l && tr[u].r <= r) return tr[u];
	    pushdown(u);
	    int mid = tr[u].l + tr[u].r >> 1;
	    if (r <= mid) return query(u << 1, l, r);
	    else if (l > mid) return query(u << 1 | 1, l, r);
	    else
	    {
	        node res;
	        auto lt = query(u << 1, l, mid);
	        auto rt = query(u << 1 | 1, mid + 1, r);
	        pushup(res, lt, rt);
	        return res;
	    }
	}
};
```

### 线段树分治（二分图）

```cpp
struct Segment_Tree
{
	// 定义后读入数组a build(1, 1, n)后即可直接使用
	int n; // 数组长度
	vector<int> a; // 原数组
    vector<bool> ans; // 当前时刻是否是二分图
	struct node
	{
		int l, r; // 左右边界
		// 需要维护的其他信息
		vector<PII> v; 
	};
	vector<node> tr;
    struct DSU
    {
        int n;
        vector<int> p, high;
        struct node
        {
            int x, y, hy;
        };
        stack<node> stk;

        DSU(int n) : n(n), p(n + 1), high(n + 1, 0)
        {
            for (int i = 1; i <= n; i ++ ) p[i] = i;
        }
        // 查找x的根
        int find(int x)
        {
            while (x != p[x]) x = p[x];
            return p[x];
        }
        // 按秩合并x和y
        void merge(int x, int y)
        {
            x = find(x), y = find(y);
            if (high[x] > high[y]) swap(x, y);
            stk.push({x, y, high[y]});
            p[x] = y;
            high[y] += (high[x] == high[y]);
        }
        // 撤销合并
        void cancel(int nw)
        {
            while (stk.size() > nw)
            {
                auto t = stk.top();
                stk.pop();
                p[t.x] = t.x;
                high[t.y] = t.hy;
            }
        }
    } dsu;
	Segment_Tree(int n) : n(n), dsu(2 * n + 1), ans(n + 1, false), tr((n + 1) * 4) {};

	void build(int u, int l, int r)
	{
		tr[u] = {l, r};
		if (l == r) return;
		int mid = l + r >> 1;
		build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
	}
	// 区间修改：a[l...r] push_back pi
	void modify(int u, int l, int r, PII pi)
	{
    	if (tr[u].l >= l && tr[u].r <= r)
    	{
    	    tr[u].v.push_back(pi);
			return;
    	}
    	int mid = tr[u].l + tr[u].r >> 1;
    	if (l <= mid) modify(u << 1, l, r, pi);
    	if (r > mid) modify(u << 1 | 1, l, r, pi);
	}
    void work(int u)
    {
        bool flag = false; // 没有奇环
        int nw = dsu.stk.size();
        for (auto t : tr[u].v)
        {
            int x = t.first, y = t.second;
            dsu.merge(x, y + n), dsu.merge(x + n, y);
            if (dsu.find(x) == dsu.find(y))
            {
                flag = true;
                break;
            }
        }
        if (!flag)
        {
            if (tr[u].l == tr[u].r) ans[tr[u].l] = true;
            else work(u << 1), work(u << 1 | 1);
        }
        dsu.cancel(nw);
    }
};
```

### 线段树合并/分裂
```cpp
struct Segment_Tree
{
    struct Node
    {
        vector<int> ch;
        int val;
        Node() : val(0), ch(2) {}
    };
    vector<Node> tr;
    vector<int> rt;
    stack<int> pool;
    int tot, rtc, delcnt;
    Segment_Tree() : tot(0), rtc(1), delcnt(0), rt(2, 0), tr(1) {}

    // 新建结点 返回结点编号
    int newnode()
    {
        if (pool.empty())
        {
            tr.emplace_back();
            return (++ tot);
        }
        else
        {
            int res = pool.top(); pool.pop();
            return res;
        }
    }
    // 删除结点u
    void del(int u)
    {
        pool.push(u);
        tr[u].ch[0] = tr[u].ch[1] = tr[u].val = 0;
    }
    // 单点修改: 加x个pos (当前结点为u 表示范围为[l,r])
    void modify(int &u, int l, int r, int pos, int x)
    {
        if (!u) u = newnode();
        tr[u].val += x;
        if (l == r) return;
        int mid = l + r >> 1;
        if (pos <= mid) modify(tr[u].ch[0], l, mid, pos, x);
        else modify(tr[u].ch[1], mid + 1, r, pos, x);
    }
    // 区间查询: 返回[lq,rq]内数值个数 (当前结点为u 表示范围为[l,r])
    int query(int u, int l, int r, int lq, int rq)
    {
        if (rq < l || lq > r) return 0;
        if (lq <= l && rq >= r) return tr[u].val;
        int mid = l + r >> 1;
        return query(tr[u].ch[0], l, mid, lq, rq) + query(tr[u].ch[1], mid + 1, r, lq, rq);
    }
    // 返回第k小的值
    int kth(int u, int l, int r, int k)
    {
        if (l == r) return l;
        int mid = l + r >> 1;
        if (tr[tr[u].ch[0]].val >= k) return kth(tr[u].ch[0], l, mid, k);
        else return kth(tr[u].ch[1], mid + 1, r, k - tr[tr[u].ch[0]].val);
    }
    // 合并结点ab
    int merge(int a, int b)
    {
        if (!a || !b) return a + b;
        tr[a].val += tr[b].val;
        tr[a].ch[0] = merge(tr[a].ch[0], tr[b].ch[0]);
        tr[a].ch[1] = merge(tr[a].ch[1], tr[b].ch[1]);
        del(b);
        return a;
    }
    // 分裂以x为根的子树为xy两棵树 其中x的大小是k
    void split(int x, int &y, int k)
    {
        if (!x) return;
        y = newnode();
        int v = tr[tr[x].ch[0]].val;
        if (k > v) split(tr[x].ch[1], tr[y].ch[1], k - v);
        else swap(tr[x].ch[1], tr[y].ch[1]);
        if (k < v) split(tr[x].ch[0], tr[y].ch[0], k);
        tr[y].val = tr[x].val - k;
        tr[x].val = k;
    }
};
// 使用样例
void solve()
{
    int n, m; cin >> n >> m;
    Segment_Tree sg;
    for (int i = 1; i <= n; i ++ )
    {
        int x; cin >> x;
        sg.modify(sg.rt[1], 1, n, i, x);
    }
    while (m -- )
    {
        int op; cin >> op;
        int p, x, y, t, q, k;
        if (op == 0) // 将p中[x,y]的值移到一个新的线段树
        {
            cin >> p >> x >> y;
            int q1 = sg.query(sg.rt[p], 1, n, 1, y), q2 = sg.query(sg.rt[p], 1, n, x, y);
            int a = 0;
            sg.rt.emplace_back();
            sg.split(sg.rt[p], sg.rt[++ sg.rtc], q1 - q2);
            sg.split(sg.rt[sg.rtc], a, q2);
            sg.rt[p] = sg.merge(sg.rt[p], a);
        }
        else if (op == 1) // 合并线段树xy
        {
            cin >> x >> y;
            sg.rt[x] = sg.merge(sg.rt[x], sg.rt[y]);
        }
        else if (op == 2) // 在线段树p中加入x个q
        {
            cin >> p >> x >> q;
            sg.modify(sg.rt[p], 1, n, q, x);
        }
        else if (op == 3) // 查询线段树p中[x,y]数的个数
        {
            cin >> p >> x >> y;
            cout << sg.query(sg.rt[p], 1, n, x, y) << '\n';
        }
        else if (op == 4) // 查询线段树p中第k小的数
        {
            cin >> p >> k;
            if (sg.tr[sg.rt[p]].val < k) cout << -1 << '\n';
            else cout << sg.kth(sg.rt[p], 1, n, k) << '\n';
        }
    }
}
```

### 可持久化线段树（单点修改/查询、区间修改/查询（标记永久化）、区间第 k 大）

```cpp
struct Segment_Tree
{
	// 定义后build()即可使用
	const static int maxn = 1e5 + 10;
	int n; // 数组长度
	int a[maxn]; // 初始数组
	struct node
	{
	    int ls, rs; // 左右儿子编号
		int l, r; // 左右边界
		// 维护信息
	    int sum;
		int cnt;
		int tag; // 懒标记
	} tr[maxn * 25];
	int root[maxn]; // 不同版本根结点编号
	int idx;
	Segment_Tree(int n) : n(n), idx(0) {};

	void pushup(node &u, node &lt, node &rt)
	{
		u.l = lt.l, u.r = rt.r;
		u.sum = lt.sum + rt.sum + u.tag * (u.r - u.l + 1);
		u.cnt = lt.cnt + rt.cnt;
	}
	void pushup(int u)
	{
		pushup(tr[u], tr[tr[u].ls], tr[tr[u].rs]);
	}
	// 新建区间[l, r] 返回根结点编号
	int build(int l, int r)
	{
	    int p = ++ idx;
	    tr[p].l = l, tr[p].r = r;
	    if (l == r)
	    {
			tr[p].sum = a[l];
			tr[p].cnt = 0;
	        return p;
	    }
	    int mid = l + r >> 1;
	    tr[p].ls = build(l, mid);
	    tr[p].rs = build(mid + 1, r);
		pushup(p);
	    return p;
	}
	// 单点修改 a[pos] += x
	// p为查询版本v的根结点root[v] 返回修改后新树的根结点编号
	int modify(int p, int pos, int x)
	{
	    int q = ++ idx;
	    tr[q] = tr[p]; // 复制结点
	    if (tr[q].l == pos && tr[q].r == pos)
	    {
	        tr[q].sum += x;
			tr[q].cnt ++ ;
	        return q;
	    }
	    int mid = tr[q].l + tr[q].r >> 1;
	    if (pos <= mid) tr[q].ls = modify(tr[p].ls, pos, x);
	    else tr[q].rs = modify(tr[p].rs, pos, x);
		pushup(q);
	    return q;
	}
	// 区间修改 a[l...r] += x
	// p为查询版本v的根结点root[v] 返回修改后新树的根结点编号
	int modify(int p, int l, int r, int x)
	{
	    int q = ++ idx;
	    tr[q] = tr[p];
	    if (tr[q].l >= l && tr[q].r <= r)
	    {
	        tr[q].tag += x;
	        tr[q].sum += (tr[q].r - tr[q].l + 1) * x;
	        return q;
	    }
	    int mid = tr[q].l + tr[q].r >> 1;
	    if (l <= mid) tr[q].ls = modify(tr[p].ls, l, r, x);
	    if (r > mid) tr[q].rs = modify(tr[p].rs, l, r, x);
	    pushup(q);
	    return q;
	}
	// 单点查询 返回查询结点 p为查询版本v的根结点root[v]
	node query(int p, int pos)
	{
	    if (tr[p].l == tr[p].r) return tr[p];
    	int mid = tr[p].l + tr[p].r >> 1;
    	if (pos <= mid) return query(tr[p].ls, pos);
    	else return query(tr[p].rs, pos);
	}
	// 区间查询 返回查询区间和 p为查询版本v的根结点root[v] 标记永久化
	int query(int p, int l, int r, int tag)
	{
    	if (tr[p].l >= l && tr[p].r <= r) return tr[p].sum + tag * (tr[p].r - tr[p].l + 1);
    	int mid = tr[p].l + tr[p].r >> 1;
    	int res = 0;
    	tag += tr[p].tag;
    	if (l <= mid) res += query(tr[p].ls, l, r, tag);
    	if (r > mid) res += query(tr[p].rs, l, r, tag);
    	return res;
	}
	// 查询区间[l, r]第k大 返回区间第k大在整个数组里的排名
	int kth(int p, int q, int k)
	{
	    if (tr[p].l == tr[p].r) return tr[p].l;
	    int cnt = tr[tr[q].ls].cnt - tr[tr[p].ls].cnt;
	    int mid = tr[p].l + tr[p].r >> 1;
	    if (cnt >= k) return kth(tr[p].ls, tr[q].ls, k);
	    else return kth(tr[p].rs, tr[q].rs, k - cnt);
	}
};
```

### 李超线段树

要求在平面直角坐标系下维护两个操作：

1. 在平面上加入一条线段。记第 $i$ 条被插入的线段的标号为 $i$。
2. 给定一个数 $k$，询问与直线 $x = k$ 相交的线段中，交点纵坐标最大的线段的编号。

**强制在线**。

输入的第一行是一个整数 $n$，代表操作的个数。

接下来 $n$ 行，每行若干个用空格隔开的整数，第 $i + 1$ 行的第一个整数为 $op$，代表第 $i$ 次操作的类型。

若 $op = 0$，则后跟一个整数 $k$，代表本次操作为查询所所有与直线 $x = (k + lastans - 1) \bmod 39989 + 1$ 相交的线段中，交点纵坐标最大的线段编号。

若 $op = 1$，则后跟四个整数 $x_0, y_0, x_1, y_1$，记 $x_i' = (x_i + lastans - 1) \bmod 39989 + 1$，$y_i' = (y_i + lastans - 1) \bmod 10^9 + 1$。本次操作为插入一条两端点分别为 $(x_0', y_0')$，$(x_1',y_1')$ 的线段。

其中 $lastans$ 为上次询问的答案，初始时，$lastans = 0$。

对于每次查询，输出一行一个整数，代表交点纵坐标最大的线段的编号。若不存在任何一条线段与查询直线有交，则输出 $0$；若有多条线段与查询直线的交点纵坐标都是最大的，则输出编号最小的线段，同时 $lastans$ 也应更新为编号最小的一条线段。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

typedef pair<double, int> pdi;

const double eps = 1e-9;
#define MOD1 39989
#define MOD2 1000000000
#define MAXT 40000

int cmp(double x, double y)
{
    if (x - y > eps) return 1;
    if (y - x > eps) return -1;
    return 0;
}

struct line
{
    double k, b;
} p[100005];

int s[160005];
int cnt;

double calc(int id, int d) { return p[id].b + p[id].k * d; }

void add(int x0, int y0, int x1, int y1)
{
    cnt++;
    // 特判直线斜率不存在的情况
    if (x0 == x1) p[cnt].k = 0, p[cnt].b = max(y0, y1);
    else p[cnt].k = 1.0 * (y1 - y0) / (x1 - x0), p[cnt].b = y0 - p[cnt].k * x0;
}
// 对线段完全覆盖到的区间进行修改
void upd(int root, int cl, int cr, int u)
{
    int &v = s[root], mid = (cl + cr) >> 1;
    int bmid = cmp(calc(u, mid), calc(v, mid));
    if (bmid == 1 || (!bmid && u < v)) swap(u, v);
    int bl = cmp(calc(u, cl), calc(v, cl)), br = cmp(calc(u, cr), calc(v, cr));
    if (bl == 1 || (!bl && u < v)) upd(root << 1, cl, mid, u);
    if (br == 1 || (!br && u < v)) upd(root << 1 | 1, mid + 1, cr, u);
}
// 定位插入线段完全覆盖到的区间
void update(int root, int cl, int cr, int l, int r, int u)
{
    if (l <= cl && cr <= r)
    {
        upd(root, cl, cr, u);
        return;
    }
    int mid = (cl + cr) >> 1;
    if (l <= mid) update(root << 1, cl, mid, l, r, u);
    if (mid < r) update(root << 1 | 1, mid + 1, cr, l, r, u);
}
// pair max函数
pdi pmax(pdi x, pdi y)
{
    if (cmp(x.first, y.first) == -1) return y;
    else if (cmp(x.first, y.first) == 1) return x;
    else return x.second < y.second ? x : y;
}
// 查询
pdi query(int root, int l, int r, int d)
{
    if (r < d || d < l) return {0, 0};
    int mid = (l + r) >> 1;
    double res = calc(s[root], d);
    if (l == r) return {res, s[root]};
    return pmax({res, s[root]}, pmax(query(root << 1, l, mid, d), query(root << 1 | 1, mid + 1, r, d)));
}

signed main()
{
    ios::sync_with_stdio(false);
    int n, lastans = 0;
    cin >> n;
    while (n--)
    {
        int op; cin >> op;
        if (op == 1)
        {
            int x0, y0, x1, y1;
            cin >> x0 >> y0 >> x1 >> y1;
            x0 = (x0 + lastans - 1 + MOD1) % MOD1 + 1,
            x1 = (x1 + lastans - 1 + MOD1) % MOD1 + 1;
            y0 = (y0 + lastans - 1 + MOD2) % MOD2 + 1,
            y1 = (y1 + lastans - 1 + MOD2) % MOD2 + 1;
            if (x0 > x1) swap(x0, x1), swap(y0, y1);
            add(x0, y0, x1, y1);
            update(1, 1, MOD1, x0, x1, cnt);
        }
        else
        {
            int x; cin >> x;
            x = (x + lastans - 1 + MOD1) % MOD1 + 1;
            cout << (lastans = query(1, 1, MOD1, x).second) << endl;
        }
    }
    return 0;
}
```

## 单调栈

在数组中查找在当前元素之后/前的第一个比当前元素大/小的元素

```cpp
// 找在当前元素之后的比当前元素大的第一个元素
stack<int> stk; // 存的是还没有确定下一个比自身大的元素的元素下标
for (int i = 1; i <= n; i ++ )
{
	// 如果找比当前元素小的第一个元素，只需将<换成>
	while (!stk.empty() && a[stk.top()] < a[i])
	{
		ans[stk.top()] = i; // 存的是下一个比自身大的元素的元素下标
		stk.pop();
	}
	stk.push(i);
}
```

## 单调队列

维护定长区间的最小/大值

```cpp
// 定长区间的最小值
deque<int> q; // 存储序号
for (int i = 0; i < n; ++i)
{
	// 长度超出的从前开始删，直到删到长度符合要求为止
    if (!q.empty() && i - q.front() >= m) q.pop_front();
	// 从队尾开始，凡是比新入队的大的，那它再也不可能成为最小值了，就直接删掉
	// （求区间最大值把第二个条件改成<即可）
    while (!q.empty() && a[q.back()] > a[i]) q.pop_back();
    q.push_back(i); // 新元素序号入队
    if (i >= m - 1) cout << a[q.front()] << " ";
}
```



## 平衡树

### 块状链表

```cpp
struct Block_List 
{
    vector<vector<int>> tr;
    int B; // 每块大小
    Block_List(int n) : B(sqrt(n))
    {
        tr.emplace_back();
        tr.back().emplace_back(INF);
    }

    // 返回x所在的块编号
    int ffind(int x)
    {
        for (int i = 0; i < tr.size(); i ++ )
        {
            if (tr[i].back() >= x) return i;
        }
        return -1;
    }
    // 插入一个数x
    void insert(int x)
    {
        int id = ffind(x); // 找到x在哪一块
        tr[id].emplace(lower_bound(tr[id].begin(), tr[id].end(), x), x);
        if (tr[id].size() > B)
        {
            tr.emplace(tr.begin() + id + 1, tr[id].begin() + B / 2, tr[id].end());
            tr[id].erase(tr[id].begin() + B / 2, tr[id].end());
        }
    }
    // 删除一个数x，如有多个只删一个
    void erase(int x)
    {
        int id = ffind(x);
        tr[id].erase(lower_bound(tr[id].begin(), tr[id].end(), x));
        if (!tr[id].size()) tr.erase(tr.begin() + id);
    }
    // 排名为x的数的值
    int Qkth(int x)
    {
        for (int i = 0; i < tr.size(); i ++ )
        {
            if (tr[i].size() >= x) return tr[i][x - 1];
            else x -= tr[i].size();
        }
        return -1;
    }
    // 值为x的数的排名
    int Qnum(int x)
    {
        int cnt = 0;
        for (int i = 0; i < tr.size(); i ++ )
        {
            if (tr[i].back() >= x)
            {
                cnt += lower_bound(tr[i].begin(), tr[i].end(), x) - tr[i].begin();
                return cnt + 1;
            }
            else cnt += tr[i].size();
        }
        return -1;
    }
    // 值为x的数的前驱的值
    int Qpre(int x)
    {
        int id = ffind(x);
        auto wei = lower_bound(tr[id].begin(), tr[id].end(), x);
        if (wei == tr[id].begin()) return tr[id - 1].back();
        else return *--wei;
    }
    // 值为x的数的后继的值
    int Qnxt(int x)
    {
        int id = ffind(x + 1);
        auto wei = upper_bound(tr[id].begin(), tr[id].end(), x);
        // 左闭右开，所以wei=end表示找不到
        if (wei == tr[id].end()) return tr[id + 1].front();
        else return *wei;
    }
};
```

### Splay（单点修改）

```cpp
struct Splay_Tree
{
	// 修改最大结点数后 需要插入INF和-INF 后使用
	static const int maxn = 1e6 + 10;
	int idx;  // 当前创建到的结点编号
	int root; // 根结点编号
	struct node
	{
		int ch[2]; // 子结点 左0右1
		int fa;	   // 父结点
		int val;   // 结点权值
		int cnt;   // 当前权值相同的结点个数
		int sz;	   // 子树大小
		void init(int p, int v)
		{
			fa = p, val = v;
			cnt = sz = 1;
		}
	} tr[maxn];
	Splay_Tree() : idx(0), root(0)
	{
		memset(tr, 0, sizeof(tr));
	}

	void pushup(int x)
	{
		tr[x].sz = tr[tr[x].ch[0]].sz + tr[tr[x].ch[1]].sz + tr[x].cnt;
	}
	int check(int x)
	{
		return tr[tr[x].fa].ch[1] == x;
	}
	void rotate(int x)
	{
		int y = tr[x].fa, z = tr[y].fa;
		int k = check(x);
		tr[z].ch[tr[z].ch[1] == y] = x;
		tr[x].fa = z;
		tr[y].ch[k] = tr[x].ch[k ^ 1];
		tr[tr[x].ch[k ^ 1]].fa = y;
		tr[x].ch[k ^ 1] = y;
		tr[y].fa = x;
		pushup(y), pushup(x);
	}
	// 如果k为0 -> 将x旋到根节点
	// 如果k不为0 -> 将x选到k的子结点
	void splay(int x, int k)
	{
		while (tr[x].fa != k)
		{
			int y = tr[x].fa, z = tr[y].fa;
			if (z != k) // 折转底，直转中
				(tr[y].ch[0] == x) ^ (tr[z].ch[0] == y)
					? rotate(x) : rotate(y);
			rotate(x);
		}
		if (!k) root = x;
	}
	// 插入值为v的结点
	void insert(int v)
	{
		int x = root, p = 0;
		while (x && tr[x].val != v) p = x, x = tr[x].ch[v > tr[x].val];
		if (x) tr[x].cnt++;
		else
		{
			x = ++idx;
			if (p) tr[p].ch[v > tr[p].val] = x;
			tr[x].init(p, v);
		}
		splay(x, 0);
	}
	// 将值为v的结点旋到根
	void find(int v)
	{
		int x = root;
		while (tr[x].ch[v > tr[x].val] && v != tr[x].val) x = tr[x].ch[v > tr[x].val];
		splay(x, 0);
	}
	// 返回值为v的前驱结点编号
	int pre(int v)
	{
		find(v);
		int x = root;
		if (tr[x].val < v) return x;
		x = tr[x].ch[0];
		while (tr[x].ch[1]) x = tr[x].ch[1];
		splay(x, 0);
		return x;
	}
	// 返回值为v的后继结点编号
	int suf(int v)
	{
		find(v);
		int x = root;
		if (tr[x].val > v) return x;
		x = tr[x].ch[1];
		while (tr[x].ch[0]) x = tr[x].ch[0];
		splay(x, 0);
		return x;
	}
	// 删除值为v的结点（如果有多个 只删除一个）
	void del(int v)
	{
		int pre_node = pre(v);
		int suc_node = suf(v);
		splay(pre_node, 0), splay(suc_node, pre_node);
		int del = tr[suc_node].ch[0];
		if (tr[del].cnt > 1)
			tr[del].cnt--, splay(del, 0);
		else
			tr[suc_node].ch[0] = 0, splay(suc_node, 0);
	}
	// 查询值为x的结点排名 如果没有值为x的结点无需单独插入删除
	int rk(int v)
	{
		insert(v);
		int res = tr[tr[root].ch[0]].sz;
		del(v);
		return res;
	}
	// 查询排名为k的结点值
	int kth(int k)
	{
		int x = root;
		while (true)
		{
			if (k <= tr[tr[x].ch[0]].sz)
				x = tr[x].ch[0];
			else if (k <= tr[tr[x].ch[0]].sz + tr[x].cnt)
				break;
			else
				k -= tr[tr[x].ch[0]].sz + tr[x].cnt, x = tr[x].ch[1];
		}
		splay(x, 0);
		return tr[x].val;
	}
};
```

### FHQ-Treap（单点修改，区间修改（文艺平衡树））

```cpp
struct FHQ_Treap
{
	static const int maxn = 1e5 + 10;
	int root, idx; // 根结点和当前已有结点编号
	struct Node
	{
		int ch[2]; // 子结点 左0右1
		int val; // 结点权值
		int pri; // 结点优先级
		int sz; // 子树大小
		int cnt; // 值相同的结点个数
		int tag; // 懒标记
	} tr[maxn];
	FHQ_Treap() : root(0), idx(0)
	{
		memset(tr, 0, sizeof(tr));
	}

	// 新建结点
	int get_node(int v)
	{
		tr[++idx].val = v;
		tr[idx].ch[0] = tr[idx].ch[1] = 0;
		tr[idx].sz = tr[idx].cnt = 1;
		tr[idx].pri = rand();
		tr[idx].tag = 0;
		return idx;
	}
	void pushup(int u)
	{
		tr[u].sz = tr[tr[u].ch[0]].sz + tr[tr[u].ch[1]].sz + tr[u].cnt;
	}
	void pushdown(int u)
	{
	    if (tr[u].tag)
		{
	        swap(tr[u].ch[0], tr[u].ch[1]);
	        tr[tr[u].ch[0]].tag ^= 1;
	        tr[tr[u].ch[1]].tag ^= 1;
	        tr[u].tag = 0;
	    }
	}
	// 分裂为小于等于key和大于key的两棵树 引用传回两棵树的根结点
	void split(int u, int x, int& lt, int& rt)
	{
	    if (u == 0)
		{
	        lt = rt = 0;
	        return;
	    }
	    pushdown(u);
	    if (tr[tr[u].ch[0]].sz + 1 <= x) // 当前点小于x，说明分界点在右儿子
		{
	        lt = u;
	        split(tr[u].ch[1], x - tr[tr[u].ch[0]].sz - 1, tr[u].ch[1], rt);
	    }
		else // 当前点大于x，说明分界点在左儿子
		{
	        rt = u;
	        split(tr[u].ch[0], x, lt, tr[u].ch[0]);
	    }
	    pushup(u); // 更新结点u信息
	}
	// 分裂为两棵树，小树的size是大于等于sz的最小的数
	void split_sz(int u, int sz, int &x, int &y)
	{
		if (!u) x = y = 0;
		else
		{
			if (sz > tr[tr[u].ch[0]].sz)
			{
				x = u;
				split_sz(tr[u].ch[1], sz - tr[tr[u].ch[0]].sz - tr[u].cnt, tr[u].ch[1], y);
				pushup(x);
			}
			else
			{
				y = u;
				split_sz(tr[u].ch[0], sz, x, tr[u].ch[0]);
				pushup(y);
			}
		}
	}
	// 合并根结点为xy的两棵树
	int merge(int x, int y)
	{
		if (!x || !y) return x | y;
		if (tr[x].pri > tr[y].pri)
		{
			pushdown(x);
			tr[x].ch[1] = merge(tr[x].ch[1], y);
			pushup(x);
			return x;
		}
		else
		{
			pushdown(y);
			tr[y].ch[0] = merge(x, tr[y].ch[0]);
			pushup(y);
			return y;
		}
	}
	// 按xyz的顺序合并三棵树
	int merge(int x, int y, int z)
	{
		return merge(merge(x, y), z);
	}
	// 插入值为c的结点
	void insert(int c)
	{
		int x, y, z;
		split(root, c, y, z);
		split(y, c - 1, x, y);
		if (!y) y = get_node(c);
		else
		{
			tr[y].cnt++;
			tr[y].sz++;
		}
		root = merge(x, y, z);
	}
	// 删除值为c的结点（如有多个只删除一个）
	void remove(int c)
	{
		int x, y, z;
		split(root, c, y, z);
		split(y, c - 1, x, y);
		tr[y].cnt--;
		tr[y].sz--;
		if (!tr[y].cnt) y = 0;
		root = merge(x, y, z);
	}
	// 根据值返回排名
	int get_rank_by_key(int c)
	{
		int x, y;
		split(root, c - 1, x, y);
		int rk = tr[x].sz + 1;
		root = merge(x, y);
		return rk;
	}
	// 根据排名返回值
	int get_key_by_rank(int rk)
	{
		int x, y;
		split_sz(root, rk, x, y);
		int u = x, key;
		while (u) key = tr[u].val, u = tr[u].ch[1];
		root = merge(x, y);
		return key;
	}
	// 返回值为c的结点的前驱结点的值
	int get_prev(int c)
	{
		int x, y;
		split(root, c - 1, x, y);
		int u = x, key;
		while (u) key = tr[u].val, u = tr[u].ch[1];
		root = merge(x, y);
		return key;
	}
	// 返回值为c的结点的后继结点的值
	int get_next(int c)
	{
		int x, y;
		split(root, c, x, y);
		int u = y, key;
		while (u) key = tr[u].val, u = tr[u].ch[0];
		root = merge(x, y);
		return key;
	}
	// 翻转区间[l, r]
	void turnover(int l, int r)
	{
		int lt, rt, md;
		split(root, r, lt, rt);
		split(lt, l - 1, lt, md);
		tr[md].tag ^= 1;
		root = merge(lt, md, rt);
	}
	// 输出当前数组
	void dfs(int u)
	{
	    if (!u) return;
	    pushdown(u);
	    dfs(tr[u].ch[0]);
	    cout << tr[u].val << ' ';
	    dfs(tr[u].ch[1]);
	}
};
```

### 可持久化平衡树 可持久化文艺平衡树（单点修改、区间修改）

```cpp
struct FHQ_Tree
{
    static const int maxn = 5e5 + 10;
    int idx; // 当前创建到的结点编号
    int root; // 根结点编号
	int rot[maxn]; // 不同版本的根结点编号
    struct node
	{
        int ch[2]; // 子结点 左0右1
        int val; // 结点权值
        int pri; // 结点优先级
        int sz; // 子树大小
        int tag; // 懒标记
        int sum; // 节点的权值和
    } tr[maxn * 50];
    FHQ_Tree() : idx(0), root(0)
	{
        memset(tr, 0, sizeof(tr));
		memset(rot, 0, sizeof(rot));
    }

	// 创建值为x的新结点
    int getnode(int x)
	{
		tr[++idx].val = x;
		tr[idx].pri = rand();
		tr[idx].sz = 1;
		tr[idx].ch[0] = tr[idx].ch[1] = 0;
		tr[idx].tag = 0;
		tr[idx].sum = x;
		return idx;
    }
	// 把y的信息复制给x
    void copynode(int x, int y)
	{
        tr[x] = tr[y];
    }
    void pushup(int u)
	{
        tr[u].sz = tr[tr[u].ch[0]].sz + tr[tr[u].ch[1]].sz + 1;
		tr[u].sum = tr[tr[u].ch[0]].sum + tr[tr[u].ch[1]].sum + tr[u].val;
    }
    void pushdown(int u)
	{
		if (tr[u].tag)
		{
			int p;
			if (tr[u].ch[0])
			{
				p = ++ idx;
				copynode(p, tr[u].ch[0]);
				tr[u].ch[0] = p;
			}
			if (tr[u].ch[1])
			{
				p = ++ idx;
				copynode(p, tr[u].ch[1]);
				tr[u].ch[1] = p;
			}
			swap(tr[u].ch[0], tr[u].ch[1]);
			if (tr[u].ch[0]) tr[tr[u].ch[0]].tag ^= 1;
			if (tr[u].ch[1]) tr[tr[u].ch[1]].tag ^= 1;
			tr[u].tag = 0;
		}
    }
	// 把treap分成小于等于x和大于x的两个部分
	void split(int u, int x, int& lt, int& rt)
	{
    	if (u == 0)
		{
    	    lt = rt = 0;
    	    return;
    	}
		pushdown(u);
    	if (tr[u].val <= x)
		{
    	    lt = ++ idx;
			copynode(lt, u);
    	    split(tr[lt].ch[1], x, tr[lt].ch[1], rt);
    	    pushup(lt);
    	}
		else
		{
    	    rt = ++ idx;
			copynode(rt, u);
    	    split(tr[rt].ch[0], x, lt, tr[rt].ch[0]);
    	    pushup(rt);
    	}
	}
	// 把根结点为u的树分出一个结点数等于x的树 引用传回两棵树的根结点
    void split_sz(int u, int x, int& lt, int& rt)
	{
        if (u == 0)
		{
			lt = rt = 0;
			return;
		}
		pushdown(u);
		if (tr[tr[u].ch[0]].sz + 1 <= x)
		{
			lt = ++idx;
			copynode(lt, u);
			split_sz(tr[lt].ch[1], x - tr[tr[u].ch[0]].sz - 1, tr[lt].ch[1], rt);
			pushup(lt);
		}
		else
		{
			rt = ++idx;
			copynode(rt, u);
			split_sz(tr[rt].ch[0], x, lt, tr[rt].ch[0]);
			pushup(rt);
		}
    }
	// 合并根结点为lt rt的两棵树
    int merge(int lt, int rt)
	{
        if (lt == 0 || rt == 0)
		return lt + rt;
		if (tr[lt].pri > tr[rt].pri)
		{
			pushdown(lt);
			tr[lt].ch[1] = merge(tr[lt].ch[1], rt);
			pushup(lt);
			return lt;
		}
		else
		{
			pushdown(rt);
			tr[rt].ch[0] = merge(lt, tr[rt].ch[0]);
			pushup(rt);
			return rt;
		}
    }
	// 按xyz的顺序合并三棵树
	int merge(int x, int y, int z)
	{
		return merge(merge(x, y), z);
	}
	// 将权值为x的新结点插入根结点为rot的treap
	void insert(int& rot, int x)
	{
		int lt, rt;
		split(rot, x, lt, rt); // 先把原treap分成小于等于x和大于x两个部分
		getnode(x); // 创建值为x的结点
		rot = merge(lt, idx, rt); // 先合并小于等于x的子树和新结点 再将其与大于x的子树合并
		return;
	}
	// 在根结点为rot的树中 在第p个数后 插入值为x的数
    void insert(int& rot, int p, int x)
	{
        int lt, rt;
		split_sz(rot, p, lt, rt);
		getnode(x);
		rot = merge(lt, idx, rt);
    }
	// 在根结点为rot的树中删除值为x的结点（如有多个只删一个）
	void del(int& rot, int x)
	{
		int lt, md, rt;
		split(rot, x, lt, rt);
		split(lt, x - 1, lt, md);
		md = merge(tr[md].ch[0], tr[md].ch[1]);
		rot = merge(lt, rt);
	}
	int rk(int& rot, int x)
	{
		int lt, rt, res;
		split(rot, x - 1, lt, rt);
		res = tr[lt].sz + 1;
		rot = merge(lt, rt);
		return res;
	}
	int kth(int u, int k)
	{
		int cur = u;
		while (1)
		{
			if (k <= tr[tr[cur].ch[0]].sz) cur = tr[cur].ch[0];
			else
			{
				k -= tr[tr[cur].ch[0]].sz + 1;
				if (k <= 0) return cur;
				else cur = tr[cur].ch[1];
			}
		}
	}
	int pre(int& rot, int x)
	{
		int lt, rt, res;
		split(rot, x - 1, lt, rt);
		if (lt == 0) return 0;
		res = kth(lt, tr[lt].sz);
		rot = merge(lt, rt);
		return res;
	}
	int suf(int& rot, int x)
	{
		int lt, rt, res;
		split(rot, x, lt, rt);
		if (rt == 0) return 0;
		res = kth(rt, 1);
		rot = merge(lt, rt);
		return res;
	}
	// 根结点为rot的树上 翻转区间[l, r]
	void turnover(int& rot, int l, int r)
	{
		int lt, rt, md;
		split(rot, r, lt, rt);
		split(lt, l - 1, lt, md);
		tr[md].tag ^= 1;
		rot = merge(lt, md, rt);
	}
	// 根结点为rot的树上查询区间[l, r]的和
	int query(int& rot, int l, int r)
	{
		int lt, rt, md;
		split(rot, r, lt, rt);
		split(lt, l - 1, lt, md);
		int ans = tr[md].sum;
		rot = merge(lt, md, rt);
		return ans;
	}
};
```

## K-D Tree

### 二维偏序

```cpp
struct KDTree
{
    // 二维偏序
    // 功能1：g[x][y] += val ==> p = {x, y}  A = val 读入后insert(root, 0)即可
    // 功能2：g[x1][y1]...g[x2][y2]矩阵求和 ==> q[1] = {x1, x2} q[2] = {y1, y2} 读入后调用query(root) 输出ans即为答案
    const double alpha = 0.75;
    const static int maxn = 1e5 + 10;
    const static int K = 2;
    struct Node
    {
        int l, r, sum, val, sz, Min[K], Max[K], d[K];
    } tr[maxn];
    int n, ans, root, len;
    int p[K], q[K][2], A;
    int D, num, h[maxn];
    KDTree(int n) : n(n), ans(0), root(0), len(0), D(0), num(0)
    {
        for (int i = 0; i < K; ++i)
        {
            p[i] = 0;
            for (int j = 0; j < 2; j ++ ) q[i][j] = 0;
        }
        for (int i = 0; i < maxn; ++i) h[i] = 0;
        for (int i = 0; i < maxn; ++i)
        {
            tr[i].l = tr[i].r = tr[i].sum = tr[i].val = tr[i].sz = 0;
            for (int j = 0; j < K; ++j)
            {
                tr[i].Min[j] = INF;
                tr[i].Max[j] = -INF;
                tr[i].d[j] = 0;
            }
        }
    }

    inline void update(int x)
    {
        int l = tr[x].l, r = tr[x].r;
        tr[x].sz = tr[l].sz + tr[r].sz + 1;
        tr[x].sum = tr[l].sum + tr[r].sum + tr[x].val;
        for (int i = 0; i < K; i++)
        {
            if (l) tr[x].Max[i] = max(tr[l].Max[i], tr[x].Max[i]), tr[x].Min[i] = min(tr[l].Min[i], tr[x].Min[i]);
            if (r) tr[x].Max[i] = max(tr[r].Max[i], tr[x].Max[i]), tr[x].Min[i] = min(tr[r].Min[i], tr[x].Min[i]);
        }
    }
    inline void build(int &x, int l, int r, int k)
    {
        auto cmp = [&](const int &a, const int &b)
        {
            return tr[a].d[D] < tr[b].d[D];
        };
        if (l > r) return;
        int mid = (l + r) >> 1;
        D = k; nth_element(h + l, h + mid + 1, h + r + 1, cmp);
        x = h[mid]; tr[x].sum = tr[x].val;
        for (int i = 0; i < K; i++) tr[x].Max[i] = tr[x].Min[i] = tr[x].d[i];
        build(tr[x].l, l, mid - 1, (k + 1) % K);
        build(tr[x].r, mid + 1, r, (k + 1) % K);
        update(x);
    }
    inline void erase(int &x)
    {
        if (!x) return;
        h[++num] = x;
        erase(tr[x].l), erase(tr[x].r);
        x = 0;
    }
    inline void rebuild(int &x, int k)
    {
        h[num = 1] = ++len;
        tr[len].sz = 1;
        for (int i = 0; i < K; i++) tr[len].d[i] = p[i];
        tr[len].val = tr[len].sum = A;
        erase(x), build(x, 1, num, k);
    }
    inline void insert(int &x, int k)
    {
        if (!x)
        {
            tr[x = ++len].sz = 1, tr[x].val = tr[x].sum = A;
            for (int i = 0; i < K; i++) tr[x].Max[i] = tr[x].Min[i] = tr[x].d[i] = p[i];
            return;
        }
        if (p[k] < tr[x].d[k])
        {
            if (tr[tr[x].l].sz > tr[x].sz * alpha) rebuild(x, k);
            else insert(tr[x].l, (k + 1) % K);
        }
        else
        {
            if (tr[tr[x].r].sz > tr[x].sz * alpha) rebuild(x, k);
            else insert(tr[x].r, (k + 1) % K);
        }
        update(x);
    }
    inline bool check_range(int x)
    {
        if (!x) return 0;
        for (int i = 0; i < K; i++)
            if (q[i][0] > tr[x].Min[i] || q[i][1] < tr[x].Max[i]) return 0;
        return 1;
    }
    inline bool check_point(int x)
    {
        if (!x) return 0;
        for (int i = 0; i < K; i++)
            if (tr[x].d[i] < q[i][0] || tr[x].d[i] > q[i][1]) return 0;
        return 1;
    }
    inline bool check(int x)
    {
        if (!x) return 0;
        for (int i = 0; i < K; i++)
            if (q[i][1] < tr[x].Min[i] || q[i][0] > tr[x].Max[i]) return 0;
        return 1;
    }
    inline void query(int x)
    {
        if (check_range(x))
        {
            ans += tr[x].sum;
            return;
        }
        if (check_point(x)) ans += tr[x].val;
        if (check(tr[x].l)) query(tr[x].l);
        if (check(tr[x].r)) query(tr[x].r);
    }
};
```

### 三维偏序

有 $ n $ 个元素，第 $ i $ 个元素有 $ a_i,b_i,c_i $ 三个属性，设 $ f(i) $ 表示满足 $ a_j \leq a_i $ 且 $ b_j \leq b_i $ 且 $ c_j \leq c_i $ 且 $ j \ne i $ 的 $j$ 的数量。

对于 $ d \in [0, n) $，求 $ f(i) = d $ 的数量。

输入第一行两个整数 $ n,k $，表示元素数量和最大属性值。

接下来 $ n $ 行，每行三个整数 $ a_i ,b_i,c_i $，分别表示三个属性值。

输出 $ n $ 行，第 $ d + 1 $ 行表示 $ f(i) = d $ 的 $ i $ 的数量。

```cpp
#include <bits/stdc++.h>
#define RG register
#define il inline
using namespace std;
const int N = 200010;
int n, tot, rt, cd, f[N];
struct node
{
    int d[3];
} p[N];
bool operator<(node a, node b) { return a.d[0] < b.d[0]; }
struct kdnode
{
    int d[2], l[2], r[2], s[2], v, sum;
} t[N];
bool operator<(kdnode x, kdnode y) { return x.d[cd] < y.d[cd]; }
int l[2], r[2];

#define ls t[i].s[0]
#define rs t[i].s[1]
#define mid ((l + r) >> 1)
il void update(int i)
{
    for (int k = 0; k < 2; k++)
    {
        t[i].l[k] = t[i].r[k] = t[i].d[k];
        if (ls)
        {
            t[i].l[k] = min(t[i].l[k], t[ls].l[k]);
            t[i].r[k] = max(t[i].r[k], t[ls].r[k]);
        }
        if (rs)
        {
            t[i].l[k] = min(t[i].l[k], t[rs].l[k]);
            t[i].r[k] = max(t[i].r[k], t[rs].r[k]);
        }
    }
    t[i].sum = t[ls].sum + t[rs].sum + t[i].v;
}
int rebuild(int l, int r, int D)
{
    if (l > r)
        return 0;
    cd = D;
    nth_element(t + l, t + mid, t + r + 1);
    t[mid].s[0] = rebuild(l, mid - 1, D ^ 1);
    t[mid].s[1] = rebuild(mid + 1, r, D ^ 1);
    update(mid);
    return mid;
}
void insert(int &i, int D)
{
    if (!i)
    {
        i = ++tot;
        t[i].v = t[i].sum = 0;
        t[i].l[0] = t[i].r[0] = t[i].d[0] = r[0];
        t[i].l[1] = t[i].r[1] = t[i].d[1] = r[1];
    }
    if (r[0] == t[i].d[0] && r[1] == t[i].d[1])
    {
        t[i].v++;
        t[i].sum++;
        return;
    }
    insert(t[i].s[t[i].d[D] > r[D]], D ^ 1);
    update(i);
}
#define ckm(dd) (l[dd] <= t[i].l[dd] && t[i].r[dd] <= r[dd])
#define ckd(dd) (l[dd] <= t[i].d[dd] && t[i].d[dd] <= r[dd])
#define cke(dd) (t[i].r[dd] < l[dd] || r[dd] < t[i].l[dd])
int query(int i, int D)
{
    if (!i || cke(0) || cke(1))
        return 0;
    if (ckm(0) && ckm(1))
        return t[i].sum;
    RG int ret = 0;
    if (ckd(0) && ckd(1))
        ret += t[i].v;
    ret += query(ls, D ^ 1) + query(rs, D ^ 1);
    return ret;
}

int main()
{
    cin >> n; int k; cin >> k;
    for (RG int i = 1; i <= n; i++)
        for (RG int j = 0; j < 3; j++)
            cin >> p[i].d[j];
    sort(p + 1, p + n + 1);
    RG int pos = 1, nxt = 1, lim = 10000, ans;
    while (pos <= n)
    {
        while (nxt <= n && (nxt == pos || p[nxt].d[0] == p[nxt - 1].d[0]))
        {
            r[0] = p[nxt].d[1];
            r[1] = p[nxt].d[2];
            insert(rt, 0);
            nxt++;
        }
        for (RG int i = pos; i < nxt; i++)
        {
            r[0] = p[i].d[1];
            r[1] = p[i].d[2];
            f[ans = query(rt, 0) - 1]++;
        }
        pos = nxt;
        if (pos <= n && pos >= lim)
        {
            rt = rebuild(1, tot, 0);
            lim = pos / 10000 * 10000 + 10000;
        }
    }
    for (RG int i = 0; i < n; i ++ ) cout << f[i] << '\n';
}
```

## 莫队

### 普通莫队

离线查询

```cpp
struct Mo
{
	// 下方代码解决区间内有多少不同数字 读入初始数组后init(m)
	const static int maxn = 1e6 + 10;
	typedef pair<pair<int, int>, int> PPI;
	int n; // 原始数组大小
	int m; // 询问数
	int sz; // 每一块大小
	int bnum; // 分成了多少块
	int belong[maxn]; // 每个元素属于哪个块
	vector<int> a; // 初始数组
	vector<PPI> q; // 询问区间 [[l, r], id]
	vector<int> ans; // 答案
	Mo(int n) : n(n), a(n + 1) {};

	// 初始化 传入询问个数
	void init(int siz)
	{
		m = siz;
		q.resize(m + 1);
		ans.resize(m + 1);
		sz = sqrt(n);
		bnum = ceil((double)n / sz);
    	for (int i = 1; i <= bnum; i ++ )
    	    for (int j = (i - 1) * sz + 1; j <= i * sz; j ++ )
    	    {
    	        belong[j] = i; // 标记每个元素属于哪个块
    	    }
	}
	function<bool(PPI, PPI)> cmp = [&](PPI a, PPI b)
    {
        return (belong[a.first.first] ^ belong[b.first.first]) ?
			belong[a.first.first] < belong[b.first.first] :
			((belong[a.first.first] & 1) ?
				a.first.second < b.first.second :
				a.first.second > b.first.second);
    };
	// 计算答案
	void cal()
	{
		sort(q.begin() + 1, q.end(), cmp);
		int l = 1, r = 0, cnt = 0;
		map<int, int> cnt; // 存储每个数字出现次数
		for (int i = 1; i <= m; i ++ )
    	{
    	    int ql = q[i].first.first, qr = q[i].first.second;
    	    while(l < ql) cnt -= !--cnt[a[l ++ ]];
    	    while(l > ql) cnt += !cnt[a[-- l]] ++;
    	    while(r < qr) cnt += !cnt[a[++ r]] ++;
    	    while(r > qr) cnt -= !--cnt[a[r -- ]];
    	    ans[q[i].second] = cnt;
    	}
	}
};
```

### 带修莫队

在线修改，离线查询

```cpp
struct Mo
{
	// 下方代码解决区间内有多少不同数字 读入初始数组后init(m)
	const static int maxn = 2e5 + 10;
	typedef pair<pair<int, int>, int> PPI;
	int n; // 原始数组大小
	int m; // 询问数
	int sz; // 每一块大小
	int nw;
	int bnum; // 分成了多少块
	int belong[maxn]; // 每个元素属于哪个块
	vector<int> a; // 初始数组
	vector<int> ans; // 答案
	// map<int, int> cnt; // 每个数字出现了多少次（数据范围小可修改为数组）
	struct query // 询问
	{
		int l, r, t, id;
	} q[maxn];
	struct modify // 修改
	{
		int pos, x;
	} md[maxn];
	int cnt1, cnt2;
	Mo(int n) : n(n), a(n + 1), cnt1(0), cnt2(0), nw(0) {};

	// 初始化 传入询问个数
	void init(int siz)
	{
		m = siz;
		ans.resize(m + 1);
		sz = pow(n, 2.0 / 3.0);
		bnum = ceil((double)n / sz);
    	for (int i = 1; i <= bnum; i ++ )
    	    for (int j = (i - 1) * sz + 1; j <= i * sz; j ++ )
    	    {
    	        belong[j] = i; // 标记每个元素属于哪个块
    	    }
	}
	// 输入查询区间[l, r]
	void InQuery(int l, int r)
	{
		q[++ cnt1].l = l;
		q[cnt1].r = r;
		q[cnt1].t = cnt2;
		q[cnt1].id = cnt1;
	}
	// 输入修改单点a[pos] = x
	void InModify(int pos, int x)
	{
		md[++ cnt2].pos = pos;
		md[cnt2].x = x;
	}
	function<bool(query, query)> cmp = [&](query a, query b)
    {
        return (belong[a.l] ^ belong[b.l]) ?
			belong[a.l] < belong[b.l] :
			((belong[a.r] ^ belong[b.r] ?
				belong[a.r] < belong[b.r] :
				a.t < b.t));
    };
	void add(int pos)
	{
		if (!cnt[a[pos]]) nw ++ ;
		cnt[a[pos]] ++ ;
	}
	void del(int pos)
	{
		cnt[a[pos]] -- ;
		if (!cnt[a[pos]]) nw -- ;
	}
	// 计算答案
	void cal()
	{
		sort(q + 1, q + cnt1 + 1, cmp);
		int l = 1, r = 0, time = 0;
		for (int i = 1; i <= cnt1; i ++ )
		{
			int ql = q[i].l, qr = q[i].r, qt = q[i].t;
			while (l < ql) del(l ++ );
			while (l > ql) add( -- l);
			while (r > qr) del(r -- );
			while (r < qr) add( ++ r);
			while (time < qt)
			{
				time ++ ;
				if (ql <= md[time].pos && md[time].pos <= qr) del(md[time].pos);
				swap(a[md[time].pos], md[time].x);
				if (ql <= md[time].pos && md[time].pos <= qr) add(md[time].pos);
			}
			while (time > qt)
			{
				if (ql <= md[time].pos && md[time].pos <= qr) del(md[time].pos);
				swap(a[md[time].pos], md[time].x);
				if (ql <= md[time].pos && md[time].pos <= qr) add(md[time].pos);
				time -- ;
			}
			ans[q[i].id] = nw;
		}
	}
};
```

## 左偏树/可并堆

```cpp
struct Merge_Heap
{
	const static int maxn = 1e5 + 10;
	int n;
	vector<int> a;
	struct node
	{
		int ch[2]; // 左右儿子
		int val; // 结点权值
		int dist; // 距离
		int rot; // 结点所在堆的根
		bool st; // 结点是否还存在
		int fa; // 父结点编号
	} tr[maxn];
	int idx;
	Merge_Heap(int n) : n(n), idx(0), a(n + 1)
	{
		memset(tr, 0, sizeof(tr));
		tr[0].dist = -1;
	}

	void input(int id, int x)
	{
		tr[id].val = x;
		tr[id].rot = id;
		tr[id].st = true;
		idx = id;
	}
	// 查询结点x所在树的根结点编号
	int find(int x)
	{
		return tr[x].rot == x ? x : tr[x].rot = find(tr[x].rot);
	}
	// 合并根为x和y的两棵树
	// 需要传入find(u) 和 find(v)
	// 传入前先确定 x!=y
	int merge(int x, int y)
	{
		if (!x || !y) return x + y;
		if (tr[x].val > tr[y].val || (tr[x].val == tr[y].val && x > y)) swap(x, y);
		tr[x].ch[1] = merge(tr[x].ch[1], y);
		tr[tr[x].ch[1]].fa = x;
		if (tr[tr[x].ch[0]].dist < tr[tr[x].ch[1]].dist) swap(tr[x].ch[0], tr[x].ch[1]);
		tr[x].dist = tr[tr[x].ch[1]].dist+ 1;
		return x;
	}
	// 建树O(n) 返回树的根结点
	int build()
	{
		queue<int> Q;
    	for(int i = 1; i <= n; i ++ ) Q.push(i);
    	int x, y, z;
    	while (Q.size() > 1)
		{
    	    x = Q.front(); Q.pop();
    	    y = Q.front(); Q.pop();
    	    z = merge(x,y); Q.push(z);
		}
    	return Q.front();
	}
	// 将值为x的结点插进根结点为y的树
	void insert(int x, int y)
	{
		tr[++ idx].val = x;
		tr[idx].rot = idx;
		tr[idx].st = true;
		tr[y].rot = tr[idx].rot = merge(idx, y);
	}
	// 删除根结点x
	void erase(int x)
	{
		int ul=tr[x].ch[0], ur=tr[x].ch[1];
    	tr[ul].fa = 0; tr[ur].fa=0;
   		tr[x].fa = tr[ul].rot = tr[ur].rot = tr[x].rot = merge(ul, ur);
		tr[x].st = false;
		tr[x].ch[0] = tr[x].ch[1] = tr[x].dist = 0;
	}
	// 删除编号为x的结点
	int Delete(int x)
	{
	    int fx = tr[x].fa;
	    int ka = merge(tr[x].ch[0], tr[x].ch[1]);
	    tr[ka].fa = fx;
	    int &ul = tr[fx].ch[0], &ur = tr[fx].ch[1];
	    ul == x ? ul = ka : ur = ka;
	    while (fx)
		{
	        if(tr[ul].dist < tr[ur].dist) swap(ul, ur);
	        if(tr[fx].dist == tr[ur].dist + 1) return find(fx);
	        tr[fx].dist = tr[ur].dist + 1;
	        ka = fx; fx = tr[x].fa;
			ul = tr[fx].ch[0], ur = tr[fx].ch[1];
	    }
		tr[x].st = false;
	    return ka;
	}
};
```



## 动态树 LCT

每一个splay维护一条从上到下在原树中深度严格递增的路径

中序遍历splay的到的每个点的深度序列严格递增

当某点在原树中有多个儿子的时候，只向其中一个儿子连一条实边（双向边），不向其他儿子不连边，其他儿子与该结点的边为虚边（单向边，由儿子指向父亲，**认父不认子**）

```cpp
struct LCT
{
    #define fa(x) tr[x].fa
    #define lc(x) tr[x].ch[0]
    #define rc(x) tr[x].ch[1]
    #define notroot(x) lc(fa(x)) == x || rc(fa(x)) == x
    int n;
    struct node
    {
        int ch[2], fa, v, sum; // v:权值 sum:异或和
        int tag; // 翻转懒标记
    };
    vector<node> tr;
    LCT(int n) : n(n), tr(n + 1) {};

    void pushup(int x)
    {
        tr[x].sum = tr[lc(x)].sum ^ tr[x].v ^ tr[rc(x)].sum;
    }
    void pushdown(int x)
    {
        if (tr[x].tag)
        {
            swap(lc(x), rc(x));
            tr[lc(x)].tag ^= 1;
            tr[rc(x)].tag ^= 1;
            tr[x].tag = 0;
        }
    }
    // 递归下传
    void pushall(int x)
    {
        if (notroot(x))
            pushall(fa(x));
        pushdown(x);
    }
    void rotate(int x)
    {
        int y = fa(x), z = fa(y), k = rc(y) == x; // y的右儿是x
        if (notroot(y)) tr[z].ch[rc(z) == y] = x;
        fa(x) = z; // z的儿是x,x的父是z
        tr[y].ch[k] = tr[x].ch[k ^ 1];
        fa(tr[x].ch[k ^ 1]) = y; // y的儿是x的异儿,x的异儿的父是y
        tr[x].ch[k ^ 1] = y;
        fa(y) = x; // x的异儿是y,y的父是x
        pushup(y);
        pushup(x); // 自底向上pushup
    }
    void splay(int x)
    {               // x伸展到根
        pushall(x); // 递归下传
        while (notroot(x))
        { // 折线转xx,直线转yx
            int y = fa(x), z = fa(y);
            if (notroot(y))
                (rc(y) == x) ^ (rc(z) == y) ? rotate(x) : rotate(y);
            rotate(x);
        }
    }
    // 打通从x到树根的路径 把路径变成一条实链
    // 完成实链的拆分和重组 把不在路径上的点踢出去 把路径上的虚边变成实边
    void access(int x)
    {
        for (int y = 0; x;)
        {
            splay(x);         // x转到当前splay的根
            rc(x) = y;        // x的右儿指向下面splay的根
            pushup(x);        // 更新x的sum
            y = x, x = fa(x); // 存x,x爬到上面的splay
        }
    }
    // 换根 把x换成根 让x变成深度最小的点
    void makeroot(int x)
    {
        access(x);      // 通路
        splay(x);       // 伸展
        tr[x].tag ^= 1; // 翻转懒标记
    }
    // 把x到y的路径分离出来 变成一条实链 并把y转到跟
    // 通过访问tr[y] 就可以得到x-y路径上的信息
    void split(int x, int y)
    {                // 分离x到y的路径
        makeroot(x); // x换根
        access(y);   // y通路
        splay(y);    // y伸展
    }
    // 返回x所在原树的树根
    // 通常用来判断两点是否在一棵树上
    int findroot(int x)
    {
        access(x);
        splay(x);
        while (lc(x)) pushdown(x), x = lc(x);
        splay(x); // 防止卡链
        return x;
    }
    // 连接x到y的边
    void link(int x, int y)
    {
        makeroot(x);
        if (findroot(y) != x) fa(x) = y; // 排除不合法连边情况
    }
    // 断开x到y的边
    void cut(int x, int y)
    {
        makeroot(x);
        if (findroot(y) == x && fa(y) == x && !lc(y)) fa(y) = 0, pushup(x); // 排除不合法断边情况
    }
    // 修改x的权值为y
    void change(int x, int y)
    {
        splay(x);
        tr[x].v = y;
        pushup(x);
    }
};
```
