# 补充
[toc]


## 可撤销并查集

```cpp
struct DSU
{
    int n;
    vector<int> p, high;
    struct node
    {
        int x, y, hy;
    };
    stack<node> stk;
    DSU(int n) : n(n), p(n + 1), high(n + 1, 0)
    {
        for (int i = 1; i <= n; i ++ ) p[i] = i;
    }
    // 查找x的根
    int find(int x)
    {
        while (x != p[x]) x = p[x];
        return p[x];
    }
    // 按秩合并x和y
    void merge(int x, int y)
    {
        x = find(x), y = find(y);
        if (high[x] > high[y]) swap(x, y);
        stk.push({x, y, high[y]});
        p[x] = y;
        high[y] += (high[x] == high[y]);
    }
    // 撤销合并
    void cancel(int nw)
    {
        while (stk.size() > nw)
        {
            auto t = stk.top();
            stk.pop();
            p[t.x] = t.x;
            high[t.y] = t.hy;
        }
    }
};
```

## 线段树分治（二分图）

```cpp
struct Segment_Tree
{
	// 定义后读入数组a build(1, 1, n)后即可直接使用
	int n; // 数组长度
	vector<int> a; // 原数组
    vector<bool> ans; // 当前时刻是否是二分图
	struct node
	{
		int l, r; // 左右边界
		// 需要维护的其他信息
		vector<PII> v; 
	};
	vector<node> tr;
    struct DSU
    {
        int n;
        vector<int> p, high;
        struct node
        {
            int x, y, hy;
        };
        stack<node> stk;

        DSU(int n) : n(n), p(n + 1), high(n + 1, 0)
        {
            for (int i = 1; i <= n; i ++ ) p[i] = i;
        }
        // 查找x的根
        int find(int x)
        {
            while (x != p[x]) x = p[x];
            return p[x];
        }
        // 按秩合并x和y
        void merge(int x, int y)
        {
            x = find(x), y = find(y);
            if (high[x] > high[y]) swap(x, y);
            stk.push({x, y, high[y]});
            p[x] = y;
            high[y] += (high[x] == high[y]);
        }
        // 撤销合并
        void cancel(int nw)
        {
            while (stk.size() > nw)
            {
                auto t = stk.top();
                stk.pop();
                p[t.x] = t.x;
                high[t.y] = t.hy;
            }
        }
    } dsu;
	Segment_Tree(int n) : n(n), dsu(2 * n + 1), ans(n + 1, false), tr((n + 1) * 4) {};

	void build(int u, int l, int r)
	{
		tr[u] = {l, r};
		if (l == r) return;
		int mid = l + r >> 1;
		build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
	}
	// 区间修改：a[l...r] push_back pi
	void modify(int u, int l, int r, PII pi)
	{
    	if (tr[u].l >= l && tr[u].r <= r)
    	{
    	    tr[u].v.push_back(pi);
			return;
    	}
    	int mid = tr[u].l + tr[u].r >> 1;
    	if (l <= mid) modify(u << 1, l, r, pi);
    	if (r > mid) modify(u << 1 | 1, l, r, pi);
	}
    void work(int u)
    {
        bool flag = false; // 没有奇环
        int nw = dsu.stk.size();
        for (auto t : tr[u].v)
        {
            int x = t.first, y = t.second;
            dsu.merge(x, y + n), dsu.merge(x + n, y);
            if (dsu.find(x) == dsu.find(y))
            {
                flag = true;
                break;
            }
        }
        if (!flag)
        {
            if (tr[u].l == tr[u].r) ans[tr[u].l] = true;
            else work(u << 1), work(u << 1 | 1);
        }
        dsu.cancel(nw);
    }
};
```

## 字符串哈希

```cpp
struct string_hash
{
    const int nn;
    const ll Base1 = 29, MOD1 = 1e9 + 7;
    const ll Base2 = 131, MOD2 = 1e9 + 9;
    vector<ll> ha1, ha2, pow1, pow2;
    vector<ll> rha1, rha2;
    string_hash(const string &ss,int n1) : nn(n1), ha1(nn + 1), ha2(nn + 1), pow1(nn + 1), pow2(nn + 1), rha1(nn + 1), rha2(nn + 1)
    {
        pow1[0] = pow2[0] = 1;
        for(int i = 1; i <= nn; i++)
        {
            pow1[i] = pow1[i - 1] * Base1 % MOD1;
            pow2[i] = pow2[i - 1] * Base2 % MOD2;
        }
        for(int i = 1; i <= nn; i++)
        {
            ha1[i] = (ha1[i - 1] * Base1 + ss[i - 1]) % MOD1;
            ha2[i] = (ha2[i - 1] * Base2 + ss[i - 1]) % MOD2;
            rha1[i] = (rha1[i - 1] * Base1 + ss[nn - i]) % MOD1;
            rha2[i] = (rha2[i - 1] * Base2 + ss[nn - i]) % MOD2;
        }
    }
    PII get_hash(int l,int r)
    {
        ll res1 = ((ha1[r] - ha1[l - 1] * pow1[r - l + 1]) % MOD1 + MOD1) % MOD1;
        ll res2 = ((ha2[r] - ha2[l - 1] * pow2[r - l + 1]) % MOD2 + MOD2) % MOD2;
        return {res1, res2};
    }
    PII get_rhash(int l, int r)
    {
        ll res1 = ((rha1[nn - l + 1] - rha1[n - r] * pow1[r - l + 1]) % MOD1 + MOD1) % MOD1;
        ll res2 = ((rha2[nn - l + 1] - rha2[n - r] * pow2[r - l + 1]) % MOD2 + MOD2) % MOD2;
        return {res1, res2};
    }
    bool is_palindrome(int l, int r)//判断ss[l, r]是否为回文串
    {
        return get_hash(l, r) == get_rhash(l, r);
    }
    PII add(PII aa,PII bb)
    {
        ll res1 = (aa.f + bb.f) % MOD1;
        ll res2 = (aa.s + bb.s) % MOD2;
        return {res1, res2};
    }
    PII mul(PII aa, ll kk) //aa *= Base的k次方
    {
        ll res1 = aa.f * pow1[kk] % MOD1;
        ll res2 = aa.s * pow2[kk] % MOD2;
        return {res1, res2};
    }
    PII pin(int l1, int r1, int l2, int r2) //拼接字符串 r1 < l2  ss = s1 + s2
    {
        return add(mul(get_hash(l2, r2), r1 - l1 + 1), get_hash(l1, r1));
    }
};

```

## 线段树合并/分裂
```cpp
struct Segment_Tree
{
    struct Node
    {
        vector<int> ch;
        int val;
        Node() : val(0), ch(2) {}
    };
    vector<Node> tr;
    vector<int> rt;
    stack<int> pool;
    int tot, rtc, delcnt;
    Segment_Tree() : tot(0), rtc(1), delcnt(0), rt(2, 0), tr(1) {}

    // 新建结点 返回结点编号
    int newnode()
    {
        if (pool.empty())
        {
            tr.emplace_back();
            return (++ tot);
        }
        else
        {
            int res = pool.top(); pool.pop();
            return res;
        }
    }
    // 删除结点u
    void del(int u)
    {
        pool.push(u);
        tr[u].ch[0] = tr[u].ch[1] = tr[u].val = 0;
    }
    // 单点修改: 加x个pos (当前结点为u 表示范围为[l,r])
    void modify(int &u, int l, int r, int pos, int x)
    {
        if (!u) u = newnode();
        tr[u].val += x;
        if (l == r) return;
        int mid = l + r >> 1;
        if (pos <= mid) modify(tr[u].ch[0], l, mid, pos, x);
        else modify(tr[u].ch[1], mid + 1, r, pos, x);
    }
    // 区间查询: 返回[lq,rq]内数值个数 (当前结点为u 表示范围为[l,r])
    int query(int u, int l, int r, int lq, int rq)
    {
        if (rq < l || lq > r) return 0;
        if (lq <= l && rq >= r) return tr[u].val;
        int mid = l + r >> 1;
        return query(tr[u].ch[0], l, mid, lq, rq) + query(tr[u].ch[1], mid + 1, r, lq, rq);
    }
    // 返回第k小的值
    int kth(int u, int l, int r, int k)
    {
        if (l == r) return l;
        int mid = l + r >> 1;
        if (tr[tr[u].ch[0]].val >= k) return kth(tr[u].ch[0], l, mid, k);
        else return kth(tr[u].ch[1], mid + 1, r, k - tr[tr[u].ch[0]].val);
    }
    // 合并结点ab
    int merge(int a, int b)
    {
        if (!a || !b) return a + b;
        tr[a].val += tr[b].val;
        tr[a].ch[0] = merge(tr[a].ch[0], tr[b].ch[0]);
        tr[a].ch[1] = merge(tr[a].ch[1], tr[b].ch[1]);
        del(b);
        return a;
    }
    // 分裂以x为根的子树为xy两棵树 其中x的大小是k
    void split(int x, int &y, int k)
    {
        if (!x) return;
        y = newnode();
        int v = tr[tr[x].ch[0]].val;
        if (k > v) split(tr[x].ch[1], tr[y].ch[1], k - v);
        else swap(tr[x].ch[1], tr[y].ch[1]);
        if (k < v) split(tr[x].ch[0], tr[y].ch[0], k);
        tr[y].val = tr[x].val - k;
        tr[x].val = k;
    }
};
// 使用样例
void solve()
{
    int n, m; cin >> n >> m;
    Segment_Tree sg;
    for (int i = 1; i <= n; i ++ )
    {
        int x; cin >> x;
        sg.modify(sg.rt[1], 1, n, i, x);
    }
    while (m -- )
    {
        int op; cin >> op;
        int p, x, y, t, q, k;
        if (op == 0) // 将p中[x,y]的值移到一个新的线段树
        {
            cin >> p >> x >> y;
            int q1 = sg.query(sg.rt[p], 1, n, 1, y), q2 = sg.query(sg.rt[p], 1, n, x, y);
            int a = 0;
            sg.rt.emplace_back();
            sg.split(sg.rt[p], sg.rt[++ sg.rtc], q1 - q2);
            sg.split(sg.rt[sg.rtc], a, q2);
            sg.rt[p] = sg.merge(sg.rt[p], a);
        }
        else if (op == 1) // 合并线段树xy
        {
            cin >> x >> y;
            sg.rt[x] = sg.merge(sg.rt[x], sg.rt[y]);
        }
        else if (op == 2) // 在线段树p中加入x个q
        {
            cin >> p >> x >> q;
            sg.modify(sg.rt[p], 1, n, q, x);
        }
        else if (op == 3) // 查询线段树p中[x,y]数的个数
        {
            cin >> p >> x >> y;
            cout << sg.query(sg.rt[p], 1, n, x, y) << '\n';
        }
        else if (op == 4) // 查询线段树p中第k小的数
        {
            cin >> p >> k;
            if (sg.tr[sg.rt[p]].val < k) cout << -1 << '\n';
            else cout << sg.kth(sg.rt[p], 1, n, k) << '\n';
        }
    }
}
```