# 补充2

## 回文自动机 （补充版）

```cpp
struct PAM
{
    // 使用前init() build(s) insert()
    /*
    -- 每个点代表的串为：从该点开始读到根结点，再读回该点（长度为奇，则与根相连的边只读一次）
    - 传入字符串下标从0开始
    - 本质不同的回文子串个数
    - 所有回文子串个数
    - 每种回文串出现的次数 cnt（需要get_cnt）
    - 每种回文串的长度 len
    - 以下标 i 为结尾的回文串的个数 sed
    - 每个回文串在原串中出现的起始位置 record
    - 0为偶串根结点 1为奇串根结点
    - 多个字符串放在同一个回文树上的一般思路：每两个字符串中间都加上两个没出现过的字符分隔，然后正常建树
    */
    const static int N = 1e6 + 10;
    const static int INF = 0x3f3f3f3f3f3f3f3f;
	string s;
	int n;
	int nxt[N][28];
	int fail[N]; // 当前节点最长回文后缀的节点
	int len[N]; // 当前节点表示的回文串的长度
	int cnt[N]; // 当前节点回文串的个数， 在getcnt后可得到全部
	int sed[N]; // 以当前节点为后缀的回文串的个数
	int record[N]; // 每个回文串在原串中出现的位置
    /* 最小回文划分
    int diff[N]; // diff[x] = len[x] - len[fail[x]]
    int slink[N]; // 当前节点x沿fail向上跳 第一个出现的u节点使得diff[x]!=diff[u]
    int dp[N]; // s[1...i]拆成回文串的最小个数
    int g[N]; // 当前节点所在等差序列的dp最小值
    */
    // /*
    int cir[N]; // 当前节点表示的回文串的循环节对应的节点编号 比如说bbb指向b
    int dep[N]; // 当前节点在该链上的深度
    int res;
    // */
	int tot; // 节点个数
	int last; // 上一个节点

	void init()
	{
		tot = 0; res = 0;
		memset(fail, 0, sizeof fail); memset(cnt, 0, sizeof cnt);
		memset(sed, 0, sizeof sed); memset(len, 0, sizeof len);
		memset(nxt, 0, sizeof nxt); memset(record, 0, sizeof record);
        /*
		memset(diff, 0, sizeof diff); memset(slink, 0, sizeof slink);
		memset(dp, 0, sizeof dp); memset(g, 0, sizeof g);
        */
        // /*
		memset(cir, 0, sizeof cir); memset(dep, 0, sizeof dep);
        // */
	}
	int newnode(int lenx)
	{
		for (int i = 0; i < 26; i++)
		nxt[tot][i] = 0;
		sed[tot] = cnt[tot] = 0;
		len[tot] = lenx;
		return tot;
	}
	void build(string ss)
	{
		tot = 0;
		newnode(0);
		tot = 1, last = 0;
		newnode(-1);
		fail[0] = 1;
		n = ss.size();
		s = " " + ss;
	}
	int getfail(int x, int n)
	{
		while (n - len[x] - 1 <= 0 || s[n - len[x] - 1] != s[n])
			x = fail[x];
		return x;
	}
	void insert(char cc, int pos)
	{
		int c = cc - 'a';
		int p = getfail(last, pos);
		if (!nxt[p][c])
		{
			tot++;
			newnode(len[p] + 2);
			fail[tot] = nxt[getfail(fail[p], pos)][c];
			len[tot] = len[p] + 2;
			sed[tot] = sed[fail[tot]] + 1;
			nxt[p][c] = tot;
            if (len[tot] - len[fail[tot]] == len[cir[fail[tot]]])
            {
                dep[tot] = dep[fail[tot]] + 1;
                cir[tot] = cir[fail[tot]];
            }
            else
            {
                dep[tot] = 1;
                cir[tot] = tot;
            }
            if (cc <= 'z') res += 2 * dep[tot] - 1;
		}
		last = nxt[p][c];
		cnt[last]++;
		record[last] = pos;
        /*
        diff[last] = len[last] - len[fail[last]];
        if (diff[last] == diff[fail[last]]) slink[last] = slink[fail[last]];
        else slink[last] = fail[last];
        */
    }
}
```

## 树的重心

```cpp
int n, sz[MAXN], mss[MAXN]; // n：总结点数（请从外部传入），sz：树的大小，mss：最大子树大小
vector<int> ctr; // 重心
void dfs(int p, int fa = 0) // 找重心
{
    sz[p] = 1, mss[p] = 0;
    for (auto [to, w] : edges[p])
        if (to != fa)
        {
            dfs(to, p);
            mss[p] = max(mss[p], sz[to]);
            sz[p] += sz[to];
        }
    mss[p] = max(mss[p], n - sz[p]);
    if (mss[p] <= n / 2) ctr.push_back(p);
}
```